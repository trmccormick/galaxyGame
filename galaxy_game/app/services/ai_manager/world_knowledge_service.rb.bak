# app/services/ai_manager/world_knowledge_service.rb
module AIManager
  class WorldKnowledgeService
    # Universal ISRU technologies and their capabilities
    ISRU_TECHNOLOGIES = {
      atmospheric_processor: {
        inputs: [:co2, :nitrogen, :methane],
        outputs: [:oxygen, :fuel, :chemicals],
        efficiency: 0.7,
        power_requirement: 50
      },

      water_extractor: {
        inputs: [:water_ice, :atmospheric_water, :regolith_water],
        outputs: [:water, :oxygen, :hydrogen],
        efficiency: 0.85,
        power_requirement: 25
      },

      mineral_processor: {
        inputs: [:regolith, :ore_deposits],
        outputs: [:metals, :silicates, :oxygen],
        efficiency: 0.6,
        power_requirement: 75
      },

      solar_farm: {
        inputs: [:solar_energy],
        outputs: [:electricity],
        efficiency: 0.22,
        power_output: 1000
      },

      nuclear_reactor: {
        inputs: [:uranium, :thorium],
        outputs: [:electricity, :heat],
        efficiency: 0.35,
        power_output: 100
      }
    }.freeze

    def initialize(celestial_body_data = nil)
      @celestial_body = celestial_body_data
    end

    def celestial_body=(data)
      @celestial_body = data
    end

    # Celestial body data for different planets/moons
    CELESTIAL_BODY_DATA = {
      moon: {
        surface: {
          regolith: { abundance: 1.0, extractable: true },
          helium3: { abundance: 0.000001, extractable: true },
          titanium: { abundance: 0.1, extractable: true },
          water_ice: { abundance: 0.1, extractable: true, locations: [:polar_craters] }
        },
        subsurface: {
          water_ice: { abundance: 0.3, extractable: true }
        },
        isru_capabilities: {
          mineral_processing: [:oxygen, :metals, :silicates],
          water_extraction: [:polar_ice],
          energy_harvesting: [:solar_energy]
        },
        challenges: [:radiation, :temperature_extremes, :micrometeorites, :dust],
        natural_resources: [:solar_energy, :helium3]
      },

      titan: {
        atmosphere: {
          nitrogen: { abundance: 0.95, extractable: true },
          methane: { abundance: 0.045, extractable: true },
          hydrogen: { abundance: 0.001, extractable: true }
        },
        surface: {
          hydrocarbons: { abundance: 0.8, extractable: true },
          water_ice: { abundance: 0.5, extractable: true },
          ammonia: { abundance: 0.1, extractable: true }
        },
        isru_capabilities: {
          atmospheric_processing: [:methane, :nitrogen, :hydrogen],
          hydrocarbon_processing: [:fuel, :plastics, :chemicals],
          water_extraction: [:surface_ice]
        },
        challenges: [:extreme_cold, :toxic_atmosphere, :cryovolcanism],
        natural_resources: [:hydrocarbons, :cryovolcanic_energy]
      },

      earth: {
        atmosphere: {
          nitrogen: { abundance: 0.78, extractable: true },
          oxygen: { abundance: 0.21, extractable: true },
          argon: { abundance: 0.009, extractable: true }
        },
        hydrosphere: {
          water: { abundance: 1.0, extractable: true },
          saltwater: { abundance: 0.97, extractable: true },
          freshwater: { abundance: 0.03, extractable: true }
        },
        biosphere: {
          biomass: { abundance: 1.0, extractable: true },
          food: { abundance: 1.0, extractable: true }
        },
        isru_capabilities: {
          agriculture: [:food, :biomass, :oxygen],
          water_purification: [:freshwater],
          mineral_processing: [:all_metals]
        },
        challenges: [:biological_hazards, :weather, :population_density],
        natural_resources: [:solar_energy, :wind_energy, :hydro_energy, :geothermal_energy]
      }
    }.freeze

    # Universal ISRU technologies and their capabilities
    ISRU_TECHNOLOGIES = {
      atmospheric_processor: {
        inputs: [:co2, :nitrogen, :methane],
        outputs: [:oxygen, :fuel, :chemicals],
        efficiency: 0.7,
        power_requirement: 50 # kW
      },

      water_extractor: {
        inputs: [:water_ice, :atmospheric_water, :regolith_water],
        outputs: [:water, :oxygen, :hydrogen],
        efficiency: 0.85,
        power_requirement: 25
      },

      mineral_processor: {
        inputs: [:regolith, :ore_deposits],
        outputs: [:metals, :silicates, :oxygen],
        efficiency: 0.6,
        power_requirement: 75
      },

      solar_farm: {
        inputs: [:solar_energy],
        outputs: [:electricity],
        efficiency: 0.22,
        power_output: 1000 # kW per farm
      },

      nuclear_reactor: {
        inputs: [:uranium, :thorium],
        outputs: [:electricity, :heat],
        efficiency: 0.35,
        power_output: 100 # kW per reactor
      }
    }.freeze

    def initialize(world_type = nil)
      @world_type = world_type&.to_sym
      @world_data = WORLD_RESOURCES[@world_type] if @world_type
    end

    def world_type=(type)
      @world_type = type&.to_sym
      @world_data = WORLD_RESOURCES[@world_type]
    end

    # Assess what resources are locally available based on actual celestial body data
    def assess_local_resources
      return {} unless @celestial_body

      available_resources = {}

      # Analyze atmospheric composition
      if @celestial_body['atmosphere_attributes']
        atmosphere = @celestial_body['atmosphere_attributes']
        atmosphere.each do |gas, data|
          next unless data.is_a?(Hash) && data['percentage'].to_f > 0.001

          available_resources[gas.downcase.to_sym] = {
            source: :atmosphere,
            abundance: data['percentage'].to_f,
            ease_of_extraction: calculate_atmospheric_extraction_difficulty(gas, data['percentage'].to_f)
          }
        end
      end

      # Analyze surface materials
      if @celestial_body['materials']
        @celestial_body['materials'].each do |material|
          material_name = material['name']&.downcase&.gsub(/\s+/, '_')&.to_sym
          abundance = material['abundance'] || material['percentage'] || 0.1

          available_resources[material_name] = {
            source: :surface,
            abundance: abundance.to_f,
            ease_of_extraction: calculate_surface_extraction_difficulty(material)
          }
        end
      end

      # Check for water ice (common on many bodies)
      if has_water_ice?
        available_resources[:water_ice] = {
          source: detect_water_ice_location,
          abundance: estimate_water_ice_abundance,
          ease_of_extraction: calculate_water_extraction_difficulty
        }
      end

      # Check geological features for additional resources
      if @celestial_body['geological_features']
        @celestial_body['geological_features'].each do |feature|
          resources_from_feature = analyze_geological_feature(feature)
          available_resources.merge!(resources_from_feature)
        end
      end

      available_resources
    end
          }
        end
      end

      available_resources
    end

    # Determine what can be produced locally based on equipment and available resources
    def assess_production_capabilities(equipment_list = [])
      return {
        oxygen_production_rate: 0,
        water_production_rate: 0,
        fuel_production_rate: 0,
        food_production_rate: 0
      } unless @celestial_body

      local_resources = assess_local_resources

      capabilities = {
        oxygen_production_rate: calculate_production_rate(:oxygen, equipment_list, local_resources),
        water_production_rate: calculate_production_rate(:water, equipment_list, local_resources),
        fuel_production_rate: calculate_production_rate(:fuel, equipment_list, local_resources),
        food_production_rate: calculate_production_rate(:food, equipment_list, local_resources)
      }

      capabilities
    end

    def calculate_production_rate(resource_type, equipment_list, local_resources)
      return 0 unless equipment_list && local_resources.any?

      rate = 0
      base_rate = 50 # kg/day per unit base rate

      equipment_list.each do |category, items|
        next unless items.is_a?(Array)

        items.each do |item|
          item_name = item.to_s.downcase
          multiplier = 1.0

          case resource_type
          when :oxygen
            if item_name.include?('oxygen_generator') || item_name.include?('electrolysis')
              multiplier = 1.0 if local_resources[:water_ice] || local_resources[:co2]
            elsif item_name.include?('sabathier')
              multiplier = 2.0 if local_resources[:co2] && local_resources[:h2]
            end
          when :water
            if item_name.include?('water_extractor') || item_name.include?('ice_mining')
              multiplier = 1.0 if local_resources[:water_ice]
            elsif item_name.include?('atmospheric_processor')
              multiplier = 0.5 if local_resources[:h2o]
            end
          when :fuel
            if item_name.include?('methane_processor') || item_name.include?('fuel_synthesis')
              multiplier = 1.0 if local_resources[:co2] || local_resources[:methane]
            end
          when :food
            if item_name.include?('hydroponics') || item_name.include?('food_synthesis')
              multiplier = 1.0 # Food production is more equipment-limited than resource-limited
            end
          end

          rate += base_rate * multiplier if multiplier > 0
        end
      end

      rate
    end

    # Augment incomplete patterns with world-specific knowledge
    def augment_pattern(pattern)
      return pattern unless @celestial_body

      augmented = pattern.deep_dup

      # Add local resource availability
      local_resources = assess_local_resources
      augmented[:world_context] = {
        world_name: @celestial_body['name'],
        world_type: @celestial_body['type'],
        local_resources: local_resources,
        production_capabilities: assess_production_capabilities(extract_equipment_list(pattern)),
        challenges: identify_challenges,
        natural_resources: identify_natural_resources
      }

      # Enhance resource dependencies with local production estimates
      if augmented[:resource_dependencies]
        augmented[:resource_dependencies][:local_production_potential] = estimate_local_production(pattern)
        augmented[:resource_dependencies][:import_requirements] = calculate_import_needs(pattern)
      end

      # Adjust economic model based on local resources
      if augmented[:economic_model]
        augmented[:economic_model][:local_resource_benefits] = calculate_local_benefits(pattern)
        augmented[:economic_model][:adjusted_import_ratio] = recalculate_import_ratio(pattern)
      end

      augmented
    end
      if augmented[:resource_dependencies]
        augmented[:resource_dependencies][:local_production_potential] = estimate_local_production(pattern)
        augmented[:resource_dependencies][:import_requirements] = calculate_import_needs(pattern)
      end

      # Adjust economic model based on local resources
      if augmented[:economic_model]
        augmented[:economic_model][:local_resource_benefits] = calculate_local_benefits(pattern)
        augmented[:economic_model][:adjusted_import_ratio] = recalculate_import_ratio(pattern)
      end

      augmented
    end

    # Provide intelligent defaults for missing pattern data
    def provide_defaults_for_missing_data(pattern)
      defaults = {}

      # Default life support requirements
      unless pattern.dig(:equipment_requirements, :inventory, :consumables)&.any?
        crew_size = estimate_crew_from_pattern(pattern)
        duration = pattern.dig(:phase_structure, :estimated_total_duration) || 720

        defaults[:life_support] = {
          oxygen: crew_size * duration * 0.84, # kg
          water: crew_size * duration * 3.0,   # kg
          food: crew_size * duration,          # kg
          unit: :kilogram
        }
      end

      # Default power requirements
      unless pattern.dig(:equipment_requirements, :power_requirements)
        equipment_count = count_equipment_items(pattern)
        defaults[:power_requirements] = {
          baseline_power: equipment_count * 10, # kW
          peak_power: equipment_count * 15       # kW
        }
      end

      # Default ISRU recommendations
      unless pattern.dig(:equipment_requirements, :isru_units)
        defaults[:isru_recommendations] = recommend_isru_equipment(pattern)
      end

      defaults
    end

    def suggest_isru_equipment(world_type, validation_errors)
      return [] unless @world_data

      suggestions = []

      validation_errors.each do |error|
        case error[:message]
        when /oxygen/i
          if @world_data[:atmosphere]&.dig(:co2, :available)
            suggestions << 'oxygen_generator'
            suggestions << 'sabathier_reactor' if @world_data[:atmosphere][:h2]&.dig(:available)
          end
        when /water/i
          if @world_data[:surface]&.dig(:ice, :available) || @world_data[:atmosphere]&.dig(:h2o, :available)
            suggestions << 'water_extractor'
          end
        when /food/i
          suggestions << 'hydroponics_module'
        end
      end

      suggestions.uniq
    end

    # Helper methods for analyzing celestial body data
    def has_water_ice?
      return false unless @celestial_body

      # Check surface temperature (water ice exists below ~200K)
      temp = @celestial_body['surface_temperature'].to_f
      return true if temp < 200

      # Check for polar regions or permanently shadowed areas
      if @celestial_body['geological_features']
        @celestial_body['geological_features'].any? do |feature|
          feature['type']&.include?('polar') || feature['type']&.include?('crater')
        end
      end

      false
    end

    def detect_water_ice_location
      return :unknown unless @celestial_body

      # Check geological features for clues
      if @celestial_body['geological_features']
        polar_features = @celestial_body['geological_features'].select do |feature|
          feature['type']&.include?('polar')
        end
        return :polar_caps if polar_features.any?

        crater_features = @celestial_body['geological_features'].select do |feature|
          feature['type']&.include?('crater')
        end
        return :craters if crater_features.any?
      end

      :surface
    end

    def estimate_water_ice_abundance
      return 0.0 unless @celestial_body

      # Base estimate based on temperature
      temp = @celestial_body['surface_temperature'].to_f
      base_abundance = case temp
                       when 0..150 then 0.8   # Very cold, likely lots of ice
                       when 151..200 then 0.3 # Cold, some ice possible
                       else 0.0               # Too warm for surface ice
                       end

      # Adjust based on geological features
      if @celestial_body['geological_features']
        polar_bonus = @celestial_body['geological_features'].count { |f| f['type']&.include?('polar') } * 0.2
        crater_bonus = @celestial_body['geological_features'].count { |f| f['type']&.include?('crater') } * 0.1
        base_abundance += polar_bonus + crater_bonus
      end

      [base_abundance, 1.0].min
    end

    def calculate_atmospheric_extraction_difficulty(gas, percentage)
      # Higher percentage = easier extraction
      base_difficulty = 5.0
      percentage_modifier = (1.0 - percentage) * 3.0  # Higher percentage = lower difficulty
      pressure_modifier = @celestial_body['known_pressure'].to_f < 1.0 ? 2.0 : 0.0  # Low pressure = harder

      [base_difficulty + percentage_modifier + pressure_modifier, 10.0].min
    end

    def calculate_surface_extraction_difficulty(material)
      base_difficulty = 3.0

      # Mining difficulty based on material properties
      if material['hardness'] || material['type']&.include?('ore')
        base_difficulty += 2.0
      end

      # Location affects difficulty
      if material['locations']&.include?('subsurface')
        base_difficulty += 1.0
      end

      [base_difficulty, 10.0].min
    end

    def calculate_water_extraction_difficulty
      return 10.0 unless @celestial_body

      base_difficulty = 5.0
      location = detect_water_ice_location

      case location
      when :polar_caps then base_difficulty += 1.0  # Accessible but cold
      when :craters then base_difficulty += 2.0     # Permanently shadowed, harder access
      when :subsurface then base_difficulty += 3.0  # Drilling required
      else base_difficulty += 1.0
      end

      [base_difficulty, 10.0].min
    end

    def analyze_geological_feature(feature)
      resources = {}

      case feature['type']
      when /volcanic|volcano/i
        resources[:volcanic_glass] = {
          source: :surface,
          abundance: 0.3,
          ease_of_extraction: 4.0
        }
      when /impact|crater/i
        resources[:impact_glass] = {
          source: :surface,
          abundance: 0.2,
          ease_of_extraction: 3.0
        }
      when /ice|polar/i
        resources[:water_ice] = {
          source: :surface,
          abundance: 0.6,
          ease_of_extraction: 6.0  # Cold temperatures make extraction harder
        }
      end

      resources
    end

    def identify_challenges
      return [] unless @celestial_body

      challenges = []

      # Temperature challenges
      temp = @celestial_body['surface_temperature'].to_f
      if temp < 200
        challenges << :extreme_cold
      elsif temp > 400
        challenges << :extreme_heat
      end

      # Pressure challenges
      pressure = @celestial_body['known_pressure'].to_f
      if pressure < 0.01
        challenges << :near_vacuum
      elsif pressure > 10
        challenges << :high_pressure
      end

      # Gravity challenges
      gravity = @celestial_body['gravity'].to_f
      if gravity < 0.3
        challenges << :low_gravity
      elsif gravity > 3.0
        challenges << :high_gravity
      end

      # Radiation (all bodies without magnetic field or atmosphere)
      if @celestial_body['magnetosphere'].nil? && pressure < 0.1
        challenges << :radiation
      end

      challenges
    end

    def identify_natural_resources
      resources = [:solar_energy] # Most bodies have access to solar energy

      # Geothermal energy for geologically active bodies
      if @celestial_body['geological_activity'].to_i > 50
        resources << :geothermal_energy
      end

      # Wind energy for bodies with atmosphere
      if @celestial_body['known_pressure'].to_f > 0.1
        resources << :wind_energy
      end

      resources
    end

    private

    def calculate_extraction_difficulty(resource, source)
      base_difficulty = case source
                        when :atmosphere then 2 # Relatively easy
                        when :surface then 3    # Moderate
                        when :subsurface then 5 # Challenging
                        else 4
                        end

      # Adjust based on world challenges
      challenges = @world_data[:challenges] || []
      difficulty_modifier = 0

      difficulty_modifier += 1 if challenges.include?(:radiation)
      difficulty_modifier += 1 if challenges.include?(:extreme_heat) || challenges.include?(:extreme_cold)
      difficulty_modifier += 1 if challenges.include?(:high_pressure) || challenges.include?(:corrosive_atmosphere)

      [base_difficulty + difficulty_modifier, 10].min # Max difficulty 10
    end

    def can_produce_oxygen?(equipment_list)
      return false unless @world_data

      # Check for oxygen production equipment
      has_atmospheric_processor = equipment_list.any? { |eq| eq.to_s.include?('atmospheric') || eq.to_s.include?('processor') }
      has_water_extractor = equipment_list.any? { |eq| eq.to_s.include?('water') && eq.to_s.include?('extract') }

      # Check if world has oxygen sources
      has_atmospheric_oxygen = @world_data.dig(:atmosphere, :oxygen, :extractable)
      has_water_ice = @world_data.dig(:surface, :water_ice, :extractable)

      (has_atmospheric_processor && has_atmospheric_oxygen) ||
      (has_water_extractor && has_water_ice)
    end

    def can_produce_water?(equipment_list)
      return false unless @world_data

      has_water_extractor = equipment_list.any? { |eq| eq.to_s.include?('water') && eq.to_s.include?('extract') }
      has_atmospheric_processor = equipment_list.any? { |eq| eq.to_s.include?('atmospheric') }

      water_sources = [
        @world_data.dig(:surface, :water_ice),
        @world_data.dig(:subsurface, :groundwater),
        @world_data.dig(:hydrosphere, :water)
      ].compact

      has_water_source = water_sources.any? { |source| source[:extractable] }

      has_water_extractor && has_water_source
    end

    def can_produce_fuel?(equipment_list)
      return false unless @world_data

      has_atmospheric_processor = equipment_list.any? { |eq| eq.to_s.include?('atmospheric') }
      has_hydrocarbon_processor = equipment_list.any? { |eq| eq.to_s.include?('hydrocarbon') }

      fuel_sources = [
        @world_data.dig(:atmosphere, :methane),
        @world_data.dig(:surface, :hydrocarbons)
      ].compact

      has_fuel_source = fuel_sources.any? { |source| source[:extractable] && source[:abundance] > 0.01 }

      (has_atmospheric_processor || has_hydrocarbon_processor) && has_fuel_source
    end

    def can_produce_food?(equipment_list)
      # Food production is rare off Earth
      return false unless @world_type == :earth

      equipment_list.any? { |eq| eq.to_s.include?('greenhouse') || eq.to_s.include?('hydroponic') }
    end

    def assess_energy_capabilities(equipment_list)
      capabilities = {}

      # Solar energy
      solar_equipment = equipment_list.count { |eq| eq.to_s.include?('solar') }
      capabilities[:solar] = solar_equipment * 100 if solar_equipment > 0 # kW

      # Nuclear energy
      nuclear_equipment = equipment_list.count { |eq| eq.to_s.include?('nuclear') || eq.to_s.include?('reactor') }
      capabilities[:nuclear] = nuclear_equipment * 100 if nuclear_equipment > 0 # kW

      # Natural energy sources
      if @world_data[:natural_resources]&.include?(:solar_energy)
        capabilities[:natural_solar] = :available
      end

      capabilities
    end

    def extract_equipment_list(pattern)
      equipment = []

      # From craft fit
      craft_fit = pattern.dig(:equipment_requirements, :craft_fit) || {}
      equipment.concat(craft_fit[:modules] || [])
      equipment.concat(craft_fit[:units] || [])

      # From inventory
      inventory = pattern.dig(:equipment_requirements, :inventory) || {}
      equipment.concat(inventory[:deployable_units] || [])

      equipment
    end

    def estimate_local_production(pattern)
      return {} unless @world_data

      production = {}
      equipment_list = extract_equipment_list(pattern)
      capabilities = assess_production_capabilities(equipment_list)

      # Estimate oxygen production
      if capabilities[:oxygen_production]
        crew_size = estimate_crew_from_pattern(pattern)
        duration = pattern.dig(:phase_structure, :estimated_total_duration) || 720
        daily_oxygen_need = crew_size * 0.84

        # Assume 70% of oxygen can be produced locally
        production[:oxygen] = {
          daily_production: daily_oxygen_need * 0.7,
          coverage_percentage: 70,
          remaining_import: daily_oxygen_need * 0.3
        }
      end

      # Estimate water production
      if capabilities[:water_production]
        crew_size = estimate_crew_from_pattern(pattern)
        duration = pattern.dig(:phase_structure, :estimated_total_duration) || 720
        daily_water_need = crew_size * 3.0

        production[:water] = {
          daily_production: daily_water_need * 0.8,
          coverage_percentage: 80,
          remaining_import: daily_water_need * 0.2
        }
      end

      production
    end

    def calculate_import_needs(pattern)
      local_production = estimate_local_production(pattern)
      imports = {}

      # Calculate what still needs to be imported
      local_production.each do |resource, data|
        if data[:remaining_import] && data[:remaining_import] > 0
          imports[resource] = {
            amount_needed: data[:remaining_import],
            timeframe: pattern.dig(:phase_structure, :estimated_total_duration) || 720,
            priority: resource == :oxygen ? :critical : :high
          }
        end
      end

      imports
    end

    def calculate_local_benefits(pattern)
      benefits = 0
      local_production = estimate_local_production(pattern)

      # Calculate cost savings from local production
      local_production.each do |resource, data|
        coverage = data[:coverage_percentage] || 0
        # Assume $100/kg import cost for life support resources
        daily_savings = (data[:daily_production] || 0) * 100
        total_savings = daily_savings * (pattern.dig(:phase_structure, :estimated_total_duration) || 720) / 24.0

        benefits += total_savings
      end

      benefits
    end

    def recalculate_import_ratio(pattern)
      original_ratio = pattern.dig(:economic_model, :import_ratio) || 0.5
      local_production = estimate_local_production(pattern)

      # Reduce import ratio based on local production capabilities
      reduction = local_production.values.sum { |data| (data[:coverage_percentage] || 0) / 100.0 } / local_production.size

      [original_ratio * (1 - reduction), 0.1].max # Minimum 10% imports for redundancy
    end

    def estimate_crew_from_pattern(pattern)
      # Use habitat count as proxy for crew size
      habitat_count = 0

      craft_fit = pattern.dig(:equipment_requirements, :craft_fit) || {}
      units = craft_fit[:units] || []

      units.each do |unit|
        habitat_count += 1 if unit.to_s.downcase.include?('habitat')
      end

      [habitat_count * 3, 1].max # At least 1 crew member
    end

    def count_equipment_items(pattern)
      equipment = extract_equipment_list(pattern)
      equipment.size
    end

    def recommend_isru_equipment(pattern)
      return [] unless @world_data

      recommendations = []
      crew_size = estimate_crew_from_pattern(pattern)

      # Always recommend atmospheric processor if world has useful atmosphere
      if @world_data[:atmosphere]&.any? { |_, data| data[:abundance] > 0.01 }
        recommendations << 'atmospheric_processor'
      end

      # Recommend water extraction if water sources available
      water_sources = [
        @world_data.dig(:surface, :water_ice),
        @world_data.dig(:subsurface, :groundwater)
      ].compact

      if water_sources.any? { |source| source[:extractable] }
        recommendations << 'water_extractor'
      end

      # Recommend mineral processor for most worlds
      if @world_data[:surface]&.any? { |_, data| data[:extractable] }
        recommendations << 'mineral_processor'
      end

      recommendations
    end
  end
end