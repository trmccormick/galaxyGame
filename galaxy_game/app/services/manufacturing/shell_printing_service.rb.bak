# app/services/manufacturing/shell_printing_service.rb
module Manufacturing
  class ShellPrintingService
      # Public API for integration spec: print_shell(inflatable_tank, shell_printer_unit)
      def print_shell(inflatable_tank, shell_printer_unit)
        # Calculate production time and materials
        production_time = calculate_production_time(inflatable_tank, shell_printer_unit)
        materials_needed = calculate_shell_materials(inflatable_tank)
        # Ensure materials are available and consume them
        ensure_materials_available(materials_needed)
        consume_materials(materials_needed)
        # Create and return the shell printing job
        create_shell_printing_job(inflatable_tank, shell_printer_unit, production_time, materials_needed)
      end
    attr_reader :settlement

    def initialize(settlement)
      @settlement = settlement
      @blueprint_lookup = Lookup::BlueprintLookupService.new
    end

    def enclose_inflatable(inflatable_tank, printer_unit)
      # 1. Validate tank is ready for enclosure
      validate_tank_ready(inflatable_tank)
      
      # 2. Validate printer can do shell printing
      validate_printer_capability(printer_unit)
      
      # 3. Calculate material requirements from tank blueprint
      materials_needed = calculate_shell_materials(inflatable_tank)
      
      # 4. Ensure materials available
      ensure_materials_available(materials_needed)
      
      # 5. Consume materials from inventory
      consume_materials(materials_needed)
      
      # 6. Calculate production time
      production_time = calculate_production_time(inflatable_tank, printer_unit)
      
      # 7. Create shell printing job
      create_shell_printing_job(inflatable_tank, printer_unit, production_time, materials_needed)
    end

    def complete_job(job)
      # 1. Mark tank as enclosed
      job.inflatable_tank.update!(
        operational_data: job.inflatable_tank.operational_data.merge(
          'enclosed' => true,
          'shell_printed_at' => Time.current.iso8601,
          'shell_materials' => job.materials_consumed
        )
      )
      
      # 2. Update job status
      job.complete!
      
      job
    end

    # Print plug/dome for pressurization target (canyon or lava tube)
    def print_pressurization_seal(pressurization_target, seal_type, printer_unit, position_data = {})
      validate_pressurization_target(pressurization_target)
      validate_printer_capability_for_seal(printer_unit, seal_type)
      
      materials_needed = calculate_seal_materials(seal_type, pressurization_target)
      ensure_materials_available(materials_needed)
      
      production_time = calculate_seal_production_time(seal_type, pressurization_target, printer_unit)
      
      # Consume materials
      consumed_materials = consume_materials(materials_needed)
      
      # Create job
      job = create_seal_printing_job(pressurization_target, seal_type, printer_unit, production_time, consumed_materials, position_data)
      
      # Record the seal in the pressurization target's operational data
      update_pressurization_progress(pressurization_target, seal_type, position_data)
      
      # Complete the job immediately (synchronous for now)
      job.complete!
      
      job
    end

    private

    def validate_tank_ready(tank)
      raise "Tank must be deployed" unless tank.operational_data['deployed']
      raise "Tank already has shell" if tank.operational_data['enclosed']
      raise "Tank not operational" unless tank.operational_data['operational']
    end

    def validate_printer_capability(printer_unit)
      raise "Printer must be operational" unless printer_unit.operational?
      
      capabilities = printer_unit.operational_data.dig('processing_capabilities', 'geosphere_processing', 'types') || []
      raise "Printer cannot process regolith for shell printing" unless capabilities.include?('regolith')
    end

    def calculate_shell_materials(inflatable_tank)
      # Use shell requirements from tank's operational data if available
      if inflatable_tank.operational_data['shell_requirements']
        shell_requirements = inflatable_tank.operational_data['shell_requirements']
      else
        # Get tank blueprint to find shell requirements
        tank_blueprint = @blueprint_lookup.find_blueprint(inflatable_tank.unit_type)
        raise "Tank blueprint not found" unless tank_blueprint
        
        # Shell requirements should be in the blueprint's shell_requirements section
        shell_requirements = tank_blueprint['shell_requirements']
        raise "No shell requirements defined for #{inflatable_tank.unit_type}" unless shell_requirements
      end
      
      materials = {}
      
      shell_requirements['material_requirements'].each do |req|
        material_name = req['material']
        needed_amount = req['amount'] || req['quantity']

        lookup_name = material_name
        item = @settlement.inventory.items.find_by(name: lookup_name)

        if item && (item.amount || 0) >= needed_amount
          composition = item.metadata&.dig('composition') || 
                        item.material_properties&.dig('composition') || 
                        {}

          materials[material_name] = {
            amount: needed_amount,
            composition: composition
          }
        else
          materials[material_name] = {
            amount: needed_amount,
            composition: {},
            missing: true
          }
        end
      end
      
      materials
    end

    def ensure_materials_available(materials_needed)
      materials_needed.each do |material_name, data|
        if data[:missing]
          raise "Insufficient materials: need #{data[:amount]}kg of #{material_name}"
        end

        # Accept depleted_regolith for depleted_regolith requests
        lookup_name = material_name
        item = Item.find_by(inventory: @settlement.inventory, name: lookup_name)

        unless item && item.amount >= data[:amount]
          raise "Insufficient materials: need #{data[:amount]}kg of #{material_name}"
        end
      end
      
      # Clean up the :missing flag
      materials_needed.each do |_, data|
        data.delete(:missing)
      end
    end

    def consume_materials(materials_needed)
      materials_needed.each do |material_name, data|
        lookup_name = material_name
        @settlement.inventory.remove_item(
          lookup_name,
          data[:amount],
          @settlement.owner
        )
      end
    end

    def calculate_production_time(inflatable_tank, printer_unit)
      # Get tank blueprint for base printing time
      tank_blueprint = @blueprint_lookup.find_blueprint(inflatable_tank.unit_type)
      shell_requirements = tank_blueprint['shell_requirements']
      
      base_time = shell_requirements['printing_time_hours'] || 10.0
      
      # Apply printer efficiency multiplier if available
      multiplier = printer_unit.operational_data.dig('component_production', 'production_rate_multiplier') || 1.0
      
      base_time / multiplier
    end

    def create_shell_printing_job(inflatable_tank, printer_unit, production_time, materials_consumed)
      ShellPrintingJob.create!(
        settlement: @settlement,
        printer_unit: printer_unit,
        inflatable_tank: inflatable_tank,
        production_time_hours: production_time,
        status: 'pending',
        materials_consumed: format_materials_for_storage(materials_consumed)
      )
    end

    def format_materials_for_storage(materials_consumed)
      materials_consumed.transform_values do |data|
        {
          'amount' => data[:amount],
          'composition' => data[:composition]
        }
      end
    end

    # Validation for pressurization targets
    def validate_pressurization_target(pressurization_target)
      raise "Pressurization target must be a Canyon or LavaTube" unless pressurization_target.is_a?(CelestialBodies::Features::Canyon) || pressurization_target.is_a?(CelestialBodies::Features::LavaTube)
      raise "Pressurization target must be accessible" unless pressurization_target.accessible?
    end

    # Validation for seal printing capability
    def validate_printer_capability_for_seal(printer_unit, seal_type)
      raise "Printer must be operational" unless printer_unit.operational?
      
      capabilities = printer_unit.operational_data.dig('processing_capabilities', 'geosphere_processing', 'types') || []
      required_capability = case seal_type
                           when 'plug' then 'regolith'
                           when 'dome' then 'regolith'
                           else raise "Unknown seal type: #{seal_type}"
                           end
      
      raise "Printer cannot process #{required_capability} for #{seal_type} printing" unless capabilities.include?(required_capability)
    end

    # Calculate materials needed for seal
    def calculate_seal_materials(seal_type, pressurization_target)
      # Base materials for different seal types
      base_requirements = case seal_type
                         when 'plug'
                           {
                             'depleted_regolith' => { amount: 2000, composition: {} },
                             'titanium_alloy' => { amount: 500, composition: {} }
                           }
                         when 'dome'
                           {
                             'depleted_regolith' => { amount: 5000, composition: {} },
                             'titanium_alloy' => { amount: 1000, composition: {} },
                             'superalloy' => { amount: 300, composition: {} }
                           }
                         else
                           raise "Unknown seal type: #{seal_type}"
                         end
      
      # Scale by feature size
      scale_factor = calculate_feature_scale_factor(pressurization_target)
      
      base_requirements.transform_values do |req|
        {
          amount: (req[:amount] * scale_factor).to_i,
          composition: req[:composition]
        }
      end
    end

    # Calculate production time for seal
    def calculate_seal_production_time(seal_type, pressurization_target, printer_unit)
      base_times = {
        'plug' => 24.0,  # hours
        'dome' => 72.0   # hours
      }
      
      base_time = base_times[seal_type] || 48.0
      
      # Scale by feature size
      scale_factor = calculate_feature_scale_factor(pressurization_target)
      scaled_time = base_time * scale_factor
      
      # Apply printer efficiency multiplier
      multiplier = printer_unit.operational_data.dig('component_production', 'production_rate_multiplier') || 1.0
      
      scaled_time / multiplier
    end

    # Calculate scale factor based on feature dimensions
    def calculate_feature_scale_factor(feature)
      if feature.is_a?(CelestialBodies::Features::LavaTube)
        # Scale by volume (cubic meters to scale factor)
        volume_m3 = feature.estimated_volume_m3 || 10000
        [1.0, volume_m3 / 10000.0].max
      elsif feature.is_a?(CelestialBodies::Features::Canyon)
        # Scale by volume
        volume_m3 = feature.volume_m3 || 50000
        [1.0, volume_m3 / 50000.0].max
      else
        1.0
      end
    end

    # Create seal printing job
    def create_seal_printing_job(pressurization_target, seal_type, printer_unit, production_time, materials_consumed, position_data)
      SealPrintingJob.create!(
        settlement: @settlement,
        printer_unit: printer_unit,
        pressurization_target: pressurization_target,
        seal_type: seal_type,
        position_data: position_data,
        production_time_hours: production_time,
        status: 'pending',
        materials_consumed: format_materials_for_storage(materials_consumed)
      )
    end

    # Update pressurization progress
    def update_pressurization_progress(pressurization_target, seal_type, position_data)
      pressurization_target.reload
      current_progress = pressurization_target.operational_data['pressurization_progress'] || {}
      
      # Initialize seal counts if needed
      current_progress['seals'] ||= {}
      current_progress['seals'][seal_type] ||= 0
      
      # Increment seal count
      current_progress['seals'][seal_type] += 1
      
      # Record position data
      current_progress['seal_positions'] ||= []
      current_progress['seal_positions'] << {
        'type' => seal_type,
        'position' => position_data,
        'installed_at' => Time.current.iso8601
      }
      
      # Check if pressurization requirements are met
      requirements = get_pressurization_requirements(pressurization_target)
      if requirements_met?(current_progress, requirements)
        current_progress['ready_for_pressurization'] = true
        current_progress['pressurization_ready_at'] = Time.current.iso8601
      end
      
      pressurization_target.update!(operational_data: pressurization_target.operational_data.merge('pressurization_progress' => current_progress))
    end

    # Get pressurization requirements for a feature
    def get_pressurization_requirements(feature)
      # Default requirements - can be overridden by feature data
      feature.operational_data.dig('pressurization_requirements') || {
        'plug' => 2,
        'dome' => 1
      }
    end

    # Check if pressurization requirements are met
    def requirements_met?(progress, requirements)
      seals = progress['seals'] || {}
      
      requirements.all? do |seal_type, required_count|
        (seals[seal_type] || 0) >= required_count
      end
    end
  end
end