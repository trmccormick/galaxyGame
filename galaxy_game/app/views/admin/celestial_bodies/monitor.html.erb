<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="<%= form_authenticity_token %>">
    <title>Admin Monitor - <%= @celestial_body.name %></title>
    <%= stylesheet_link_tag 'admin/monitor', media: 'all' %>
    <%= javascript_include_tag 'tileset_loader' %>
</head>
<body>
    <div id="mainContainer">
        <!-- Header -->
        <div id="header">
            <h1 id="planetName"><%= @celestial_body.name %> - ADMIN MONITOR</h1>
            <div id="planetInfo">
                <%= @celestial_body.type %> | 
                Radius: <%= number_to_human(@celestial_body.radius, precision: 2) %> m | 
                Gravity: <%= number_with_precision(@celestial_body.gravity, precision: 3) %>g |
                Temp: <%= number_with_precision(@celestial_body.surface_temperature, precision: 1) %>K
            </div>
        </div>
        
        <!-- Left Panel: AI Mission Controls -->
        <div id="toolPanel">
            <!-- Mission Control Section -->
            <div class="tool-section">
                <h3>AI MISSION CONTROL</h3>
                <button class="tool-button" data-test="resource_extraction">
                    ‚õèÔ∏è Test Resource Extraction
                </button>
                <button class="tool-button" data-test="base_construction">
                    üèóÔ∏è Test Base Construction
                </button>
                <button class="tool-button" data-test="isru_pipeline">
                    üè≠ Test ISRU Pipeline
                </button>
                <button class="tool-button" data-test="gcc_bootstrap">
                    üöÄ Test GCC Bootstrap
                </button>
                <button class="tool-button" onclick="window.location.href='/celestial_bodies/<%= @celestial_body.id %>'">
                    üëÅÔ∏è View Public Page
                </button>
                <button class="tool-button" onclick="window.location.href='/admin/celestial_bodies/<%= @celestial_body.id %>/edit'">
                    ‚öôÔ∏è Edit Celestial Body
                </button>
            </div>
            
            <!-- Management Tools Section -->
            <div class="tool-section">
                <h3>ADMIN TOOLS</h3>
                <button class="tool-button" onclick="window.location.href='/admin/celestial_bodies/<%= @celestial_body.id %>/edit'">
                    ‚öôÔ∏è Edit Celestial Body Properties
                </button>
                <button class="tool-button" onclick="window.location.href='/celestial_bodies/<%= @celestial_body.id %>'">
                    üëÅÔ∏è View Public Page
                </button>
            </div>
            
            <!-- Active Missions Section -->
            <div class="tool-section">
                <h3>ACTIVE MISSIONS</h3>
                <div id="missionList">
                    <% @ai_missions.each do |mission| %>
                        <div class="mission-item <%= mission[:status] %>">
                            <div class="mission-header">
                                <span class="mission-type"><%= mission[:type] %></span>
                                <span class="mission-status"><%= mission[:status].upcase %></span>
                            </div>
                            <div class="mission-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: <%= mission[:progress] %>%"></div>
                                </div>
                                <span class="progress-text"><%= mission[:progress] %>%</span>
                            </div>
                        </div>
                    <% end %>
                </div>
            </div>
            
            <!-- View Layers Section -->
            <div class="tool-section">
                <h3>MAP LAYERS</h3>
                <div class="layer-selector">
                    <button class="layer-btn active" data-layer="terrain">Terrain</button>
                    <button class="layer-btn" data-layer="water">Water</button>
                    <button class="layer-btn" data-layer="biomes">Biomes</button>
                    <button class="layer-btn" data-layer="features">Features</button>
                    <button class="layer-btn" data-layer="temperature">Temp</button>
                    <button class="layer-btn" data-layer="rainfall">Rainfall</button>
                    <button class="layer-btn" data-layer="resources">Resources</button>
                </div>
            </div>
            
            <!-- Geological Features -->
            <% if @geological_features.any? %>
                <div class="tool-section">
                    <h3>GEOLOGICAL FEATURES</h3>
                    <div class="feature-list">
                        <% @geological_features.take(5).each do |feature| %>
                            <div class="feature-item">
                                <strong><%= feature[:name] %></strong>
                                <span class="feature-type"><%= feature[:type] %></span>
                            </div>
                        <% end %>
                    </div>
                </div>
            <% end %>
        </div>
        
        <!-- Center Panel: Planetary Map -->
        <div id="canvasWrapper">
            <div id="mapOverlay">
                <div id="mapTitle"><%= @celestial_body.name %> - PLANETARY MAP</div>
                <div id="mapControls">
                    <div class="control-group">
                        <label>Zoom: <span id="zoomValue" class="value-display">1.0x</span></label>
                        <input type="range" id="zoom" min="0.5" max="4" step="0.1" value="1">
                    </div>
                </div>
            </div>
            <canvas id="planetCanvas" width="800" height="400"></canvas>
            <div id="featureTooltip" class="hidden">
                <div id="tooltipContent"></div>
            </div>
        </div>
        
        <!-- Right Panel: Sphere Data -->
        <div id="dataPanel">
            <!-- Atmosphere Section -->
            <div class="data-section">
                <h3>ATMOSPHERE</h3>
                <% if @celestial_body.atmosphere %>
                    <div class="data-row">
                        <span class="data-label">Pressure:</span>
                        <span class="data-value" id="atmo-pressure">
                            <%= number_with_precision(@celestial_body.atmosphere.pressure, precision: 4) %> bar
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Temperature:</span>
                        <span class="data-value" id="atmo-temp">
                            <%= number_with_precision(@celestial_body.atmosphere.temperature, precision: 1) %> K
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Total Liquid Mass:</span>
                        <span class="data-value" id="atmo-mass">
                            <%= number_to_human(@celestial_body.atmosphere.total_atmospheric_mass || 0, precision: 2) %> kg
                        </span>
                    </div>
                    
                    <!-- Composition -->
                    <% composition = @celestial_body.atmospheric_composition %>
                    <% if composition.any? %>
                        <h4 class="subsection">Composition:</h4>
                        <% composition.each do |gas, percentage| %>
                            <div class="data-row">
                                <span class="data-label"><%= gas %>:</span>
                                <span class="data-value"><%= number_with_precision(percentage, precision: 2) %>%</span>
                            </div>
                        <% end %>
                    <% end %>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Hydrosphere Section -->
            <div class="data-section">
                <h3>HYDROSPHERE</h3>
                <% if @celestial_body.hydrosphere %>
                    <div class="data-row">
                        <span class="data-label">Liquid Coverage:</span>
                        <span class="data-value" id="hydro-coverage">
                            <%= number_with_precision(@celestial_body.hydrosphere.water_coverage || 0, precision: 1) %>%
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Ocean Mass:</span>
                        <span class="data-value" id="hydro-ocean">
                            <%= number_to_human(@celestial_body.hydrosphere.oceans || 0, precision: 2) %> kg
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Ice Mass:</span>
                        <span class="data-value" id="hydro-ice">
                            <%= number_to_human(@celestial_body.hydrosphere.ice_caps || 0, precision: 2) %> kg
                        </span>
                    </div>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Cryosphere Section - Not Implemented -->
            <!--
            <div class="data-section">
                <h3>CRYOSPHERE</h3>
                <div class="data-row">
                    <span class="data-value warning">Not Implemented</span>
                </div>
            </div>
            -->
            </div>
            
            <!-- Biosphere Section -->
            <div class="data-section">
                <h3>BIOSPHERE</h3>
                <% if @celestial_body.biosphere %>
                    <div class="data-row">
                        <span class="data-label">Biodiversity:</span>
                        <span class="data-value" id="bio-diversity">
                            <%= number_with_precision((@celestial_body.biosphere.biodiversity_index || 0) * 100, precision: 1) %>%
                        </span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="bio-diversity-bar" 
                             style="width: <%= (@celestial_body.biosphere.biodiversity_index || 0) * 100 %>%"></div>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Habitability:</span>
                        <span class="data-value" id="bio-habitability">
                            <%= number_with_precision((@celestial_body.biosphere.habitable_ratio || 0) * 100, precision: 1) %>%
                        </span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="bio-habitability-bar" 
                             style="width: <%= (@celestial_body.biosphere.habitable_ratio || 0) * 100 %>%"></div>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Life Forms:</span>
                        <span class="data-value" id="bio-lifeforms">
                            <%= @celestial_body.biosphere.life_forms.count %>
                        </span>
                    </div>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Geosphere Section -->
            <% if @celestial_body.geosphere %>
                <div class="data-section">
                    <h3>GEOSPHERE</h3>
                    <div class="data-row">
                        <span class="data-label">Geological Activity:</span>
                        <span class="data-value" id="geo-activity">
                            <%= number_with_precision((@celestial_body.geosphere.geological_activity || 0) * 100, precision: 1) %>%
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Tectonic Active:</span>
                        <span class="data-value" id="geo-tectonic">
                            <%= @celestial_body.geosphere.tectonic_activity ? 'Yes' : 'No' %>
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Core Mass:</span>
                        <span class="data-value" id="geo-core">
                            <%= number_to_human(@celestial_body.geosphere.total_core_mass || 0, precision: 2) %> kg
                        </span>
                    </div>
                </div>
            <% end %>
        </div>
        
        <!-- Bottom Panel: Console -->
        <div id="console">
            <div class="console-line info">&gt; Admin monitoring system initialized for <%= @celestial_body.name %></div>
            <div class="console-line info">&gt; Sphere data loaded: 
                <%= @sphere_summary.select { |k, v| v }.keys.join(', ') %>
            </div>
            <div class="console-line info">&gt; Ready for AI Manager testing operations</div>
        </div>
    </div>

    <script>
        // Prevent multiple script executions (Turbo navigation issue)
        if (window.monitorScriptLoaded) {
            console.log('Monitor script already loaded, skipping...');
            // Clean up any existing intervals
            if (window.monitorUpdateInterval) {
                clearInterval(window.monitorUpdateInterval);
            }
        } else {
            window.monitorScriptLoaded = true;

        // Admin monitoring interface JavaScript
        const planetId = <%= @celestial_body.id %>;
        const planetName = '<%= @celestial_body.name %>';
        const planetType = '<%= @celestial_body.type %>';
        let updateInterval = null;

        // TerraSim-style climate zone calculations
        function calculateClimateZones(tempK, pressureBar) {
            // Simplified TerraSim calculations
            const Ts = tempK; // Surface temperature
            const Tp = Ts - 75 / (1 + 5 * pressureBar); // Polar temperature (TerraSim formula)
            const Tt = Ts * 1.1; // Tropical temperature
            
            let iceLat = 0; // Ice latitude in degrees
            let habRatio = 0; // Habitable ratio
            
            if (Tt > 273 && Tp < 273) {
                // Partial ice coverage
                habRatio = Math.pow((Tt - 273) / (Tt - Tp), 0.666667);
                iceLat = Math.asin(habRatio) * 180 / Math.PI; // Convert to degrees
            } else if (Tt < 273) {
                // Completely frozen
                habRatio = 0;
                iceLat = 90;
            } else {
                // No ice
                habRatio = 1;
                iceLat = 0;
            }
            
            return {
                surfaceTemp: Ts,
                polarTemp: Tp,
                tropicalTemp: Tt,
                iceLatitude: iceLat,
                habitableRatio: habRatio,
                // Climate zone boundaries
                polarZone: iceLat,
                temperateZone: Math.max(iceLat + 30, 45),
                tropicalZone: Math.max(iceLat + 60, 75)
            };
        }

        // Global climate data
        const planetTemp = <%= @celestial_body.atmosphere&.temperature || @celestial_body.surface_temperature || 288 %>; // Global surface temperature in K
        const planetPressure = <%= @celestial_body.atmosphere&.pressure || 1.0 %>; // Atmospheric pressure in bar
        const climate = calculateClimateZones(planetTemp, planetPressure);

        // Layer overlay colors (complete replacement with terrain-specific shades)
        const layerOverlays = {
            water: {
                terrainColors: {
                    'ocean': '#002244',    // Much darker blue for surface water (SimEarth style)
                    'deep_sea': '#001122'  // Very dark blue for deep ocean
                }
            },
            biomes: {
                terrainColors: {
                    'forest': '#228B22',   // Forest green for forests
                    'jungle': '#006400',   // Dark green for dense jungle
                    'grasslands': '#32CD32', // Lime green for grasslands
                    'plains': '#FFFF00',   // Yellow for plains
                    'swamp': '#808000',    // Olive for swamps
                    'boreal': '#228B22',   // Forest green for boreal forests/taiga
                    'arctic': '#ffffff',   // White for polar ice caps (cryosphere biome)
                    'desert': function(lat) { // Climate-based desert coloring
                        // Use latitude to determine desert temperature type
                        // Deserts near poles are cold (white/beige), equatorial deserts are warm (yellow)
                        const absLat = Math.abs(lat);
                        if (absLat > climate.iceLatitude + 20) {
                            return '#ffeedd'; // Cold desert (beige-white)
                        } else {
                            return '#ffdd44'; // Warm desert (yellow)
                        }
                    }
                }
            },
            features: {
                terrainColors: {
                    'rock': '#696969'     // Gray for bare rock
                }
            },
            temperature: {
                // Global temperature overlay - independent of terrain type
                // SimEarth style: Red (>30¬∞C), Yellow (0-30¬∞C), Brown/Blue (<0¬∞C)
                getOverlayColor: function(latitude, elevation, globalTemp, pressure) {
                    // Calculate local temperature based on latitude and planetary conditions
                    const absLat = Math.abs(latitude);
                    
                    // Base temperature gradient from equator to poles
                    let baseTemp;
                    if (absLat < 30) {
                        // Tropical: hot
                        baseTemp = globalTemp - 273.15 + 20 - (absLat / 30) * 10; // Convert K to C, adjust for latitude
                    } else if (absLat < 60) {
                        // Temperate
                        baseTemp = globalTemp - 273.15 - ((absLat - 30) / 30) * 20;
                    } else {
                        // Polar: cold
                        baseTemp = globalTemp - 273.15 - 20 - ((absLat - 60) / 30) * 30;
                    }
                    
                    // Elevation affects temperature (higher = colder)
                    const elevationTemp = baseTemp - (elevation * 20);
                    
                    // Atmospheric pressure affects temperature retention
                    const pressureTemp = elevationTemp * (0.5 + pressure * 0.5);
                    
                    // SimEarth temperature color scale
                    if (pressureTemp > 30) {
                        return '#ff0000'; // Bright red for very hot
                    } else if (pressureTemp > 15) {
                        return '#ff6600'; // Orange-red for hot
                    } else if (pressureTemp > 0) {
                        return '#ffff00'; // Yellow for warm
                    } else if (pressureTemp > -15) {
                        return '#aa6600'; // Brown for cool
                    } else {
                        return '#0088ff'; // Blue for cold
                    }
                },
                // Minimal terrain-specific overrides for extreme cases
                terrainColors: {
                    // Only override in very specific cases where local terrain dramatically affects microclimate
                }
            },
            rainfall: {
                terrainColors: {
                    'jungle': '#0066ff',   // Dark blue for high rainfall tropics
                    'swamp': '#0044ff',   // Very dark blue for wetlands
                    'forest': '#4488ff',  // Medium blue for moderate rainfall forests
                    'boreal': '#88aaff',  // Light blue for temperate rainfall
                    'desert': '#ffff00'   // Yellow for arid/low rainfall
                }
            },
            resources: {
                terrainColors: {
                    'rock': '#ffd700',    // Gold for mineral-rich rock
                    'desert': '#daa520'   // Darker gold for desert minerals
                }
            }
        };

        // Initialize monitoring
        document.addEventListener('DOMContentLoaded', function() {
            setupAITestButtons();
            setupLayerToggles();
            updateLayerButtons(); // Initialize button states
            setupZoomControl();
            startDataPolling();
            renderTerrainMap(); // Add terrain rendering
            logConsole('System initialized', 'info');
        });

        // Color blending utility function
        function blendColors(baseColor, overlayColor, alpha) {
            // Convert hex colors to RGB
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            const base = hexToRgb(baseColor);
            const overlay = hexToRgb(overlayColor);
            
            if (!base || !overlay) return baseColor;
            
            // Blend colors: result = base * (1-alpha) + overlay * alpha
            const r = Math.round(base.r * (1 - alpha) + overlay.r * alpha);
            const g = Math.round(base.g * (1 - alpha) + overlay.g * alpha);
            const b = Math.round(base.b * (1 - alpha) + overlay.b * alpha);
            
            // Convert back to hex
            return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        }

        // Analyze atmospheric conditions for planetary rendering effects
        function analyzeAtmosphericConditions(temperature, pressure, composition) {
            // Default values for airless bodies
            let hasAtmosphere = false;
            let isHabitable = false;
            let dominantGas = 'none';
            let visualEffects = {
                haze: 0,
                colorTint: null,
                aurora: false
            };

            // Check if planet has significant atmosphere
            if (pressure > 0.01) { // More than trace atmosphere
                hasAtmosphere = true;

                // Analyze composition if available
                if (composition && typeof composition === 'object') {
                    let maxPercentage = 0;
                    let dominantGasKey = null;

                    // Find dominant gas
                    Object.keys(composition).forEach(gas => {
                        const gasData = composition[gas];
                        const percentage = gasData.percentage || gasData;
                        if (percentage > maxPercentage) {
                            maxPercentage = percentage;
                            dominantGasKey = gas;
                        }
                    });

                    if (dominantGasKey) {
                        dominantGas = dominantGasKey;
                        const gasData = composition[dominantGasKey];
                        const commonName = gasData.common_name || dominantGasKey;

                        // Determine visual effects based on dominant gas and conditions
                        if (dominantGasKey === 'CO2') {
                            visualEffects.haze = 0.8; // Thick CO2 atmosphere creates haze
                            visualEffects.colorTint = '#ffaaaa'; // Slight reddish tint
                        } else if (dominantGasKey === 'N2' && composition['O2']) {
                            // Nitrogen-oxygen atmosphere (Earth-like)
                            const oxygenPercent = composition['O2'].percentage || composition['O2'];
                            if (oxygenPercent >= 19.5 && oxygenPercent <= 23.5) {
                                isHabitable = true;
                                visualEffects.haze = 0.1; // Clear atmosphere
                            }
                        } else if (dominantGasKey === 'CH4') {
                            visualEffects.haze = 0.6; // Methane atmosphere
                            visualEffects.colorTint = '#ffffaa'; // Slight yellowish tint
                        }
                    }
                }

                // Temperature-based effects
                if (temperature < 273) { // Below freezing
                    visualEffects.haze += 0.2; // Cold atmospheres can be hazy
                } else if (temperature > 400) { // Hot planet
                    visualEffects.haze += 0.3; // Hot atmospheres distort light
                }

                // Pressure-based effects
                if (pressure > 5) {
                    visualEffects.haze += 0.4; // High pressure creates thick atmosphere
                }

                // Clamp haze to reasonable range
                visualEffects.haze = Math.max(0, Math.min(1, visualEffects.haze));

                // Aurora effects for magnetic planets with atmosphere
                if (hasAtmosphere && temperature > 200 && pressure > 0.1) {
                    visualEffects.aurora = true;
                }
            }

            return {
                hasAtmosphere: hasAtmosphere,
                isHabitable: isHabitable,
                dominantGas: dominantGas,
                visualEffects: visualEffects,
                // Raw data for debugging
                temperature: temperature,
                pressure: pressure,
                composition: composition
            };
        }

        // Color map for terrain types (BARE TERRAIN - topographic colors only, no biome colors)
        const colors = {
            ocean: '#0066cc',        // Ocean blue
            deep_sea: '#003366',     // Deep ocean blue
            arctic: '#e8e8e8',       // Light gray (ice/snow surface, not white)
            tundra: '#b8b8b8',       // Medium gray (permafrost/gravel)
            grasslands: '#90EE90',   // Light green (grass/vegetation)
            plains: '#F0E68C',      // Khaki (dry plains)
            forest: '#228B22',      // Forest green (trees)
            jungle: '#006400',      // Dark green (dense jungle)
            desert: '#F4A460',      // Sandy brown (sand/dunes)
            mountains: '#696969',   // Dim gray (rock)
            rock: '#808080',        // Gray (bare rock)
            rocky: '#808080',       // Gray (rocky terrain)
            boreal: '#228B22',      // Forest green (coniferous)
            swamp: '#556B2F'        // Dark olive green (wetlands)
        };

        // FreeCiv terrain code to terrain type mapping
        const freecivTerrainMap = {
            ' ': 'ocean',      // Ocean
            'a': 'arctic',     // Arctic
            't': 'tundra',     // Tundra
            'f': 'forest',     // Forest
            'g': 'grasslands', // Grassland
            'p': 'plains',     // Plains
            'd': 'desert',     // Desert
            'h': 'mountains',  // Hills (mapped to mountains)
            'm': 'mountains',  // Mountains
            'j': 'jungle',     // Jungle
            's': 'swamp',      // Swamp
            'r': 'rock',       // Rock (if present)
            'b': 'boreal'      // Boreal (if present)
        };

        // Function to normalize terrain type from FreeCiv data
        function normalizeTerrainType(terrainCode) {
            // Handle null/undefined
            if (!terrainCode) return 'plains';
            
            // Convert to string and trim
            const code = terrainCode.toString().trim();
            
            // First check if it's already a full terrain name
            if (colors[code]) {
                return code;
            }
            
            // Otherwise convert from FreeCiv code to full name
            const fullName = freecivTerrainMap[code];
            if (fullName) {
                return fullName;
            }
            
            // Default fallback
            console.warn("Unknown terrain code:", code, "- defaulting to plains");
            return 'plains';
        }

        function generateBasicElevation(mapData) {
            // Generate basic elevation data from terrain types for water calculation
            // Uses the same elevation ranges as TerrainDecompositionService
            const grid = mapData.grid || mapData.terrain_grid;
            const width = mapData.width || grid[0]?.length || 0;
            const height = mapData.height || grid.length;
            const elevationGrid = [];

            // Elevation ranges for different terrain types (normalized 0.0-1.0)
            const elevationRanges = {
                deep_sea: [0.0, 0.1],
                coast: [0.1, 0.2],
                plains: [0.2, 0.4],
                grasslands: [0.3, 0.5],
                forest: [0.4, 0.6],
                jungle: [0.4, 0.6],
                desert: [0.2, 0.7],
                rocky: [0.3, 0.8],
                mountains: [0.7, 1.0],
                tundra: [0.5, 0.8],
                arctic: [0.8, 1.0],
                swamp: [0.1, 0.3],
                boreal: [0.5, 0.8],
                ocean: [0.0, 0.2]  // Ocean can be various depths
            };

            for (let y = 0; y < height; y++) {
                elevationGrid[y] = [];
                for (let x = 0; x < width; x++) {
                    const rawCode = grid[y][x];
                    const terrainType = normalizeTerrainType(rawCode);
                    const range = elevationRanges[terrainType] || [0.2, 0.6]; // Default to plains range

                    // Add some randomness within the range for natural variation
                    const minElev = range[0];
                    const maxElev = range[1];
                    elevationGrid[y][x] = minElev + (Math.random() * (maxElev - minElev));
                }
            }

            return {
                grid: elevationGrid,
                width: width,
                height: height,
                layer_type: 'elevation',
                quality: 'basic_generated',
                method: 'terrain_type_based'
            };
        }
        function extractTerrainLayer(mapData, options = {}) {
            // Extract terrain layer from map data
            // options.stripVegetation: if true, converts vegetation to underlying terrain (for bare lithosphere view)
            // options.preserveVariety: if true, keeps all terrain types as-is (default)
            
            const stripVegetation = options.stripVegetation || false;
            const grid = mapData.grid || mapData.terrain_grid;
            const width = mapData.width || grid[0]?.length || 0;
            const height = mapData.height || grid.length;
            const terrainGrid = [];

            for (let y = 0; y < height; y++) {
                terrainGrid[y] = [];
                for (let x = 0; x < width; x++) {
                    const rawCode = grid[y][x];
                    let terrainType = normalizeTerrainType(rawCode);

                    // Only strip vegetation if explicitly requested (for bare lithosphere layer mode)
                    if (stripVegetation) {
                        // Convert vegetation to underlying terrain
                        switch (terrainType) {
                            case 'forest':
                            case 'jungle':
                            case 'boreal':
                                terrainType = 'plains'; // Vegetation grows on plains
                                break;
                            case 'grasslands':
                                terrainType = 'plains'; // Grasslands are plains with vegetation
                                break;
                            case 'swamp':
                                terrainType = 'plains'; // Swamps are wet plains
                                break;
                            case 'arctic':
                                terrainType = 'tundra'; // Arctic is icy tundra
                                break;
                        }
                    }
                    // Otherwise, preserve the terrain type as-is for full variety display

                    terrainGrid[y][x] = terrainType;
                }
            }

            return {
                grid: terrainGrid,
                width: width,
                height: height,
                layer_type: 'terrain',
                vegetation_stripped: stripVegetation
            };
        }

        function extractWaterLayer(mapData, elevationData, hydrosphereData) {
            // Dynamic water layer extraction using SimEarth bathtub system
            // Water fills from lowest elevations based on hydrosphere mass
            const grid = mapData.grid || mapData.terrain_grid;
            const width = mapData.width || grid[0]?.length || 0;
            const height = mapData.height || grid.length;
            const waterGrid = [];

            // Get hydrosphere data for water volume calculation
            const totalWaterMass = hydrosphereData?.total_water_mass || hydrosphereData?.total_liquid_mass || 0;
            const planetName = <%= raw @celestial_body.name.to_json %>;

            // Calculate water volume as percentage (0.0 to 1.0)
            // Earth has significant water, Mars starts minimal
            let waterVolume = 0.0;
            if (planetName.toLowerCase().includes('earth')) {
                // Earth: Use actual hydrosphere data or default to ~70% water coverage
                waterVolume = totalWaterMass > 0 ? Math.min(totalWaterMass / 1.4e21, 1.0) : 0.7; // 1.4e21 kg is Earth's water
            } else if (planetName.toLowerCase().includes('mars')) {
                // Mars: Minimal water, can increase with terraforming
                waterVolume = totalWaterMass > 0 ? Math.min(totalWaterMass / 1e18, 0.1) : 0.01; // Much less water
            } else {
                // Other planets: Minimal water by default
                waterVolume = totalWaterMass > 0 ? Math.min(totalWaterMass / 1e20, 0.05) : 0.0;
            }

            // Calculate sea level using elevation data (SimEarth bathtub system)
            let seaLevel = 0.5; // Default sea level (mid-elevation)
            if (elevationData && elevationData.grid && waterVolume > 0) {
                // Flatten and sort elevations to find water distribution
                const elevations = elevationData.grid.flat().filter(e => e !== null && e !== undefined);
                if (elevations.length > 0) {
                    elevations.sort((a, b) => a - b);
                    const waterTiles = Math.floor(waterVolume * elevations.length);
                    seaLevel = waterTiles > 0 && waterTiles < elevations.length ?
                        elevations[waterTiles - 1] : elevations[Math.floor(elevations.length * waterVolume)] || 0.5;
                }
            }

            console.log(`Water layer: ${planetName}, volume=${waterVolume.toFixed(3)}, seaLevel=${seaLevel.toFixed(3)}`);

            for (let y = 0; y < height; y++) {
                waterGrid[y] = [];
                for (let x = 0; x < width; x++) {
                    const elevation = elevationData?.grid?.[y]?.[x] || 0.5; // Default mid-elevation

                    if (elevation < seaLevel) {
                        // Underwater - determine water type based on depth
                        const depth = seaLevel - elevation;

                        if (depth < 0.1) {
                            waterGrid[y][x] = 'coast'; // Shallow coastal water
                        } else if (depth < 0.3) {
                            waterGrid[y][x] = 'ocean'; // Normal ocean
                        } else {
                            waterGrid[y][x] = 'deep_sea'; // Deep ocean
                        }
                    } else {
                        waterGrid[y][x] = null; // Above water
                    }
                }
            }

            return {
                grid: waterGrid,
                width: width,
                height: height,
                layer_type: 'water',
                sea_level: seaLevel,
                water_volume: waterVolume,
                dynamic: true
            };
        }

        function extractBiomeLayer(mapData) {
            // Extract biomes/vegetation from map data
            // Preserves all terrain types that represent biomes/vegetation
            const grid = mapData.grid || mapData.terrain_grid;
            const width = mapData.width || grid[0]?.length || 0;
            const height = mapData.height || grid.length;
            const biomeGrid = [];

            for (let y = 0; y < height; y++) {
                biomeGrid[y] = [];
                for (let x = 0; x < width; x++) {
                    const rawCode = grid[y][x];
                    const terrainType = normalizeTerrainType(rawCode);

                    // Include all terrain types (not just vegetation)
                    // Each represents a different biome/climate zone
                    biomeGrid[y][x] = terrainType;
                }
            }

            return {
                grid: biomeGrid,
                width: width,
                height: height,
                layer_type: 'biomes'
            };
        }

        function extractResourceLayer(mapData) {
            // Extract resource/mineral deposits from Civ4 map
            // This would need more sophisticated analysis of terrain patterns
            // For now, return null to indicate not implemented
            console.log('Resource layer extraction not yet implemented');
            return null;
        }

        // Simple terrain map renderer
        function renderTerrainMap() {
            const canvas = document.getElementById('planetCanvas');
            if (!canvas) {
                console.error('Canvas element not found');
                return;
            }

            const ctx = canvas.getContext('2d');

            // Load terrain data - ALWAYS prioritize geosphere data over properties
            <%
              terrain_map_data = @celestial_body&.geosphere&.terrain_map
              terrain_json = terrain_map_data ? terrain_map_data.to_json : 'null'
              
              # Load properties data for additional layers only
              freeciv_map_data = @celestial_body&.properties&.dig('freeciv_map')
              civ4_map_data = @celestial_body&.properties&.dig('civ4_map')
              has_properties_grid = @celestial_body&.properties&.dig('terrain_grid').present?
              
              # Only load Civ4 properties data if it's from import and no other Civ4 data
              civ4_properties_data = nil
              if has_properties_grid && @celestial_body.properties['source'] == 'civ4_import' && !civ4_map_data
                civ4_properties_data = {
                  grid: @celestial_body.properties['terrain_grid'],
                  width: @celestial_body.properties['grid_width'],
                  height: @celestial_body.properties['grid_height'],
                  biome_counts: @celestial_body.properties['biome_counts'] || {}
                }
              end
            %>
            let terrainData = <%= raw terrain_json %>;
            let freecivData = <%= raw freeciv_map_data ? freeciv_map_data.to_json : 'null' %>;
            let civ4Data = <%= raw (civ4_map_data || civ4_properties_data) ? (civ4_map_data || civ4_properties_data).to_json : 'null' %>;
            let hydrosphereData = <%= raw @celestial_body&.hydrosphere ? @celestial_body.hydrosphere.attributes.to_json : 'null' %>;

            // DEBUG: Log what data sources are loaded
            console.log('=== DATA SOURCE DEBUG ===');
            console.log('terrainData (geosphere):', terrainData ? 'LOADED' : 'null');
            console.log('freecivData (properties):', freecivData ? 'LOADED' : 'null');  
            console.log('civ4Data (properties):', civ4Data ? 'LOADED' : 'null');
            if (terrainData && terrainData.grid) {
                console.log('Geosphere grid sample:', terrainData.grid[0]?.slice(0, 10));
            }
            if (civ4Data && civ4Data.grid) {
                console.log('Civ4 properties grid sample:', civ4Data.grid[0]?.slice(0, 10));
            }
            console.log('=== END DATA DEBUG ===');

            // Layer extraction system - separate terrain, water, biomes, elevation from different map sources
            let layers = {
                terrain: null,    // Bare topographic terrain (from FreeCiv)
                water: null,      // Water bodies (from FreeCiv)
                biomes: null,     // Vegetation/climate zones (from Civ4)
                resources: null,  // Mineral deposits (from Civ4)
                elevation: null   // Elevation data (from processed maps)
            };

            // Extract elevation from terrain_map FIRST (needed for water layer calculation)
            if (terrainData && terrainData.elevation) {
                layers.elevation = {
                    grid: terrainData.elevation,
                    width: terrainData.width || terrainData.elevation[0]?.length || 0,
                    height: terrainData.height || terrainData.elevation.length,
                    layer_type: 'elevation',
                    quality: terrainData.quality || 'unknown',
                    method: terrainData.method || 'unknown'
                };
                console.log('Using elevation data from terrain_map:', layers.elevation.quality, layers.elevation.method);
            } else {
                // Generate basic elevation from terrain types (fallback for water calculation)
                const elevationSource = terrainData || freecivData || civ4Data;
                if (elevationSource && elevationSource.grid) {
                    layers.elevation = generateBasicElevation(elevationSource);
                    console.log('Generated basic elevation data for water calculation');
                }
            }

            // Extract layers - GEOSPHERE DATA TAKES PRIORITY
            if (terrainData && terrainData.grid) {
                // Geosphere terrain map: Primary source for terrain
                layers.terrain = extractTerrainLayer(terrainData);
                console.log('Using terrain layer from geosphere (generated map)');
            } else if (freecivData && freecivData.grid) {
                // FreeCiv map: Fallback for terrain and water layers
                // Default: preserve variety (don't strip vegetation)
                layers.terrain = extractTerrainLayer(freecivData, { stripVegetation: false });
                layers.water = extractWaterLayer(freecivData, layers.elevation, hydrosphereData);
                console.log('Extracted terrain and water layers from FreeCiv properties (variety preserved)');
            } else if (civ4Data && civ4Data.grid) {
                // Civ4 map: Use for terrain and biome layers
                layers.terrain = extractTerrainLayer(civ4Data, { stripVegetation: false });
                layers.water = extractWaterLayer(civ4Data, layers.elevation, hydrosphereData);
                layers.biomes = extractBiomeLayer(civ4Data);
                layers.resources = extractResourceLayer(civ4Data);
                console.log('Extracted terrain, water, biome and resource layers from Civ4 properties');
            }

            // Prefer decomposed layers if available (shows current planetary conditions)
            if (terrainData && terrainData.decomposed_layers) {
                terrainData = terrainData.decomposed_layers;
                console.log('Using decomposed terrain layers (planetary conditions applied)');
            } else if (!terrainData && has_properties_grid) {
                <%
                  props_data = { grid: @celestial_body.properties['terrain_grid'], width: @celestial_body.properties['grid_width'], height: @celestial_body.properties['grid_height'], biome_counts: @celestial_body.properties['biome_counts'] }
                  props_json = props_data.to_json
                %>
                terrainData = <%= raw props_json %>;
            }

            // Fallback: use terrainData if no layers extracted
            if (!layers.terrain && terrainData) {
                layers.terrain = terrainData;
            }

            console.log('Celestial body:', <%= raw @celestial_body.name.to_json %>);
            console.log('Geosphere present:', <%= raw (@celestial_body.geosphere.present? rescue false).to_json %>);
            console.log('Terrain map in geosphere:', <%= raw (@celestial_body.geosphere&.terrain_map.present? rescue false).to_json %>);
            console.log('FreeCiv map available:', <%= raw (@celestial_body.properties&.dig('freeciv_map').present? rescue false).to_json %>);
            console.log('Civ4 map available:', <%= raw (@celestial_body.properties&.dig('civ4_map').present? rescue false).to_json %>);
            console.log('Civ4 data from properties:', <%= raw (civ4_properties_data.present? rescue false).to_json %>);
            console.log('Terrain grid in properties:', <%= raw (@celestial_body.properties&.dig('terrain_grid').present? rescue false).to_json %>);
            console.log('Layers extracted:', layers);

            // Use terrain layer by default, fallback to terrainData
            let activeTerrainData = layers.terrain || terrainData;

            if (!activeTerrainData || (!activeTerrainData.grid && !activeTerrainData.terrain_grid && !activeTerrainData.terrain)) {
                console.warn('No terrain data available - displaying message on canvas');
                logConsole('No terrain data available for rendering', 'warning');
                
                // Clear canvas and show message
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw message
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('NO TERRAIN DATA', canvas.width / 2, canvas.height / 2 - 20);
                ctx.fillText('AVAILABLE', canvas.width / 2, canvas.height / 2 + 10);
                ctx.fillText('Generate terrain map to view planetary surface', canvas.width / 2, canvas.height / 2 + 40);
                
                return;
            }
            const grid = activeTerrainData.grid || activeTerrainData.terrain_grid || activeTerrainData.terrain;
            const width = activeTerrainData.width || grid[0]?.length || 0;
            const height = activeTerrainData.height || grid.length;

            console.log('Rendering terrain map:', width, 'x', height);
            console.log('Sample grid data:', grid[0]?.slice(0, 5), grid[30]?.slice(0, 5));

            if (width === 0 || height === 0) {
                console.error('Invalid terrain dimensions');
                return;
            }

            // Set canvas size based on terrain data
            const tileSize = 8; // 8px per tile
            canvas.width = width * tileSize;
            canvas.height = height * tileSize;

            // Planet identification for special rendering
            const planetName = <%= raw @celestial_body.name.to_json %>;
// Analyze planetary conditions for data-driven rendering
            const planetaryConditions = analyzeAtmosphericConditions(
                <%= raw (@celestial_body.atmosphere&.temperature || @celestial_body.temperature || 288).to_json %>,
                <%= raw (@celestial_body.atmosphere&.pressure || 1.0).to_json %>,
                <%= raw @celestial_body.atmospheric_composition.to_json %>
            );
            
            // Dynamic elevation calculation based on biome and planetary conditions
            function calculateElevation(terrainType, latitude, temperature, pressure, x, y) {
                // First priority: Use actual elevation data from processed maps
                if (layers.elevation && layers.elevation.grid && layers.elevation.grid[y] && layers.elevation.grid[y][x] !== undefined) {
                    const elevationValue = layers.elevation.grid[y][x];
                    
                    // Elevation data is already normalized to 0-1 scale from MapLayerService
                    // Just ensure it's clamped to valid range
                    return Math.max(0, Math.min(1, elevationValue));
                }
                
                // Fallback: Calculate elevation from terrain type (legacy method)
                console.warn('Using fallback elevation calculation for', terrainType, 'at', x, y);
                
                // Base elevation by terrain type (0-1 scale)
                const baseElevations = {
                    ocean: 0.0,      // Sea level
                    deep_sea: -0.1,  // Below sea level
                    arctic: 0.1,     // Polar ice caps
                    tundra: 0.2,     // Cold plains
                    grasslands: 0.3, // Temperate plains
                    plains: 0.4,     // Higher plains
                    forest: 0.5,     // Forested hills
                    jungle: 0.5,     // Tropical hills
                    desert: 0.4,     // Desert plains (can be high or low)
                    mountains: 0.9,  // High mountains
                    rock: 0.7,       // Rocky highlands
                    boreal: 0.6,     // Boreal forests
                    swamp: 0.1       // Low wetlands
                };
                
                let elevation = baseElevations[terrainType] || 0.5;
                
                // Adjust for planetary conditions
                // Higher pressure = more atmosphere = different elevation patterns
                elevation += (pressure - 1.0) * 0.1;
                
                // Temperature affects elevation (colder planets have more extreme relief)
                const tempOffset = (temperature - 288) / 200; // 288K is Earth standard
                elevation += tempOffset * 0.2;
                
                // Latitude affects elevation (polar regions have varied elevation, not just high)
                const latFactor = Math.abs(latitude) / 90;
                // Polar regions can have both high mountains and low valleys
                const polarVariation = Math.sin(latitude * Math.PI / 180 * 4) * 0.2; // Add some variation
                elevation += latFactor * 0.05 + polarVariation;
                
                // Clamp to 0-1 range
                return Math.max(0, Math.min(1, elevation));
            }

            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Render each tile
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const rawTerrainType = grid[y][x];
                    const terrainType = normalizeTerrainType(rawTerrainType);

                    // Calculate latitude for this tile (-90 to +90)
                    const latitude = ((y / (height - 1)) - 0.5) * 180;
                    
                    // Calculate elevation for this terrain type and location
                    const elevation = calculateElevation(terrainType, latitude, planetTemp, planetPressure, x, y);

                    // Start with base color - ALWAYS terrain as base
                    let baseColor = '#000000'; // Default black
                    
                    // Terrain is ALWAYS the base layer - use standard terrain colors for all planets
                    // Earth shows full detail as it's habitable; other worlds get atmospheric tinting
                    baseColor = colors[terrainType] || '#000000';

                    // Debug: log first few tiles
                    if (y === 0 && x < 5) {
                        console.log(`Tile ${x},${y}: ${rawTerrainType} -> ${terrainType} -> ${baseColor}`);
                    }

                    let hasOverlay = false;

                    // Initialize final color to base color
                    let finalColor = baseColor;
                    if (visibleLayers.has('temperature')) {
                        const tempOverlay = layerOverlays.temperature;
                        let tempColor;
                        
                        // Check if terrain has specific temperature override (rare)
                        if (tempOverlay.terrainColors && tempOverlay.terrainColors[terrainType]) {
                            tempColor = tempOverlay.terrainColors[terrainType];
                            if (typeof tempColor === 'function') {
                                tempColor = tempColor(latitude);
                            }
                        } else {
                            // Use global temperature calculation based on latitude, elevation, and planetary conditions
                            tempColor = tempOverlay.getOverlayColor(latitude, elevation, planetTemp, planetPressure);
                        }
                        
                        // Blend temperature overlay with base color (40% opacity for SimEarth style)
                        finalColor = blendColors(baseColor, tempColor, 0.4);
                        hasOverlay = true;
                    }

                    // Apply other layer overlays (water, biomes, features overlay on terrain)
                    // Earth shows bare terrain (lithosphere only); other planets show available layers
                    const isEarth = planetName.toLowerCase().includes('earth') || planetType.toLowerCase().includes('earth');
                    
                    for (const [layerName, overlay] of Object.entries(layerOverlays)) {
                        if (layerName === 'temperature') continue; // Already handled above
                        
                        // Earth shows bare terrain - skip water and biome overlays
                        if (isEarth && (layerName === 'water' || layerName === 'biomes')) {
                            continue; // Earth shows only lithosphere (bare terrain)
                        }
                        
                        if (visibleLayers.has(layerName) && overlay.terrainColors) {
                            let overlayTerrainType = terrainType; // Default to base terrain type
                            
                            // For layer-specific overlays, use the layer's grid data instead of base terrain
                            if (layers[layerName] && layers[layerName].grid && layers[layerName].grid[y] && layers[layerName].grid[y][x] !== null) {
                                overlayTerrainType = layers[layerName].grid[y][x];
                            }
                            
                            if (overlay.terrainColors[overlayTerrainType]) {
                                let overlayColor = overlay.terrainColors[overlayTerrainType];
                                
                                if (typeof overlayColor === 'function') {
                                    overlayColor = overlayColor(latitude);
                                }
                                
                                // Blend overlay with current final color
                                finalColor = blendColors(finalColor, overlayColor, 0.7);
                                hasOverlay = true;
                            }
                        }
                    }

                    // Apply atmospheric tinting for non-Earth worlds to make them look more realistic
                    const isEarth = planetName.toLowerCase().includes('earth') || planetType.toLowerCase().includes('earth');
                    if (!isEarth) {
                        const isMars = planetName.toLowerCase().includes('mars') || planetType.toLowerCase().includes('mars');
                        const isVenus = planetName.toLowerCase().includes('venus') || planetType.toLowerCase().includes('venus');
                        const isTitan = planetName.toLowerCase().includes('titan') || planetType.toLowerCase().includes('titan');
                        
                        if (isMars) {
                            // Mars: reddish atmospheric tint
                            finalColor = blendColors(finalColor, '#CD853F', 0.3); // Sandy brown tint
                        } else if (isVenus) {
                            // Venus: yellowish atmospheric tint
                            finalColor = blendColors(finalColor, '#FFD700', 0.4); // Gold tint
                        } else if (isTitan) {
                            // Titan: orange atmospheric tint
                            finalColor = blendColors(finalColor, '#FFA500', 0.35); // Orange tint
                        } else {
                            // Generic non-Earth world: subtle atmospheric tint based on temperature
                            const tempTint = planetTemp > 288 ? '#FFFF99' : '#E0E0FF'; // Warm = yellow, cool = blue
                            const tintStrength = Math.abs(planetTemp - 288) / 200; // Temperature difference affects tint strength
                            finalColor = blendColors(finalColor, tempTint, Math.min(tintStrength, 0.2));
                        }
                    }

                    // Ensure we never have black tiles (fallback to light brown)
                    if (finalColor === '#000000' || finalColor === 'rgb(0, 0, 0)') {
                        finalColor = '#4a3c28'; // Dark brown fallback
                    }

                    ctx.fillStyle = finalColor;
                    ctx.fillRect(x * tileSize, (height - 1 - y) * tileSize, tileSize, tileSize);

                    // Add subtle border for tile definition
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x * tileSize, (height - 1 - y) * tileSize, tileSize, tileSize);
                }
            }

            const uniqueTerrains = grid.flat().filter((v, i, a) => a.indexOf(v) === i);
            console.log(`Rendered ${width}x${height} terrain map with ${Object.keys(colors).length} terrain types`);
            console.log('Terrain types found:', uniqueTerrains);
            logConsole(`Terrain map rendered: ${width}x${height} (${uniqueTerrains.length} unique terrain types: ${uniqueTerrains.join(', ')})`, 'success');
        }

        // Setup AI test buttons
        function setupAITestButtons() {
            document.querySelectorAll('.tool-button[data-test]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const testType = this.dataset.test;
                    runAITest(testType);
                });
            });
        }

        // Run AI Manager test
        function runAITest(testType) {
            logConsole(`Starting AI test: ${testType}`, 'info');
            
            fetch(`/admin/celestial_bodies/${planetId}/run_ai_test`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
                },
                body: JSON.stringify({ test_type: testType })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logConsole(data.message, 'success');
                    logConsole(`Test completed: ${JSON.stringify(data)}`, 'info');
                } else {
                    logConsole(`Test failed: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                logConsole(`Error running test: ${error.message}`, 'error');
            });
        }

        // Setup zoom control
        function setupZoomControl() {
            const zoomInput = document.getElementById('zoom');
            const zoomValue = document.getElementById('zoomValue');
            const canvas = document.getElementById('planetCanvas');
            const canvasWrapper = document.getElementById('canvasWrapper');
            
            zoomInput.addEventListener('input', function() {
                const zoom = parseFloat(this.value);
                zoomValue.textContent = zoom.toFixed(1) + 'x';
                
                // Use CSS transform to zoom the canvas
                if (zoom === 1.0) {
                    canvas.style.transform = 'none';
                    canvasWrapper.style.overflow = 'auto'; // Allow scrolling for large maps
                } else {
                    canvas.style.transform = `scale(${zoom})`;
                    canvas.style.transformOrigin = 'top left';
                    canvasWrapper.style.overflow = 'auto'; // Enable scrolling when zoomed
                }
            });
            
            // Initialize at 1.0x
            zoomValue.textContent = '1.0x';
            canvas.style.transform = 'none';
            canvasWrapper.style.overflow = 'auto';
        }

        // Start polling for data updates
        function startDataPolling() {
            updateInterval = setInterval(updateSphereData, 5000); // Update every 5 seconds
        }

        // Update sphere data from server
        function updateSphereData() {
            fetch(`/admin/celestial_bodies/${planetId}/sphere_data`)
                .then(response => response.json())
                .then(data => {
                    // Update atmosphere data
                    if (data.atmosphere.pressure !== undefined) {
                        updateElement('atmo-pressure', `${data.atmosphere.pressure.toFixed(4)} bar`);
                        updateElement('atmo-temp', `${data.atmosphere.temperature.toFixed(1)} K`);
                        updateElement('atmo-mass', formatMass(data.atmosphere.total_mass));
                    }
                    
                    // Update hydrosphere data
                    if (data.hydrosphere.water_coverage !== undefined) {
                        updateElement('hydro-coverage', `${data.hydrosphere.water_coverage.toFixed(1)}%`);
                        updateElement('hydro-ocean', formatMass(data.hydrosphere.ocean_mass));
                        updateElement('hydro-ice', formatMass(data.hydrosphere.ice_mass));
                    }
                    
                    // Update biosphere data
                    if (data.biosphere.biodiversity_index !== undefined) {
                        updateElement('bio-diversity', `${data.biosphere.biodiversity_index.toFixed(1)}%`);
                        updateProgressBar('bio-diversity-bar', data.biosphere.biodiversity_index);
                        updateElement('bio-habitability', `${data.biosphere.habitable_ratio.toFixed(1)}%`);
                        updateProgressBar('bio-habitability-bar', data.biosphere.habitable_ratio);
                        updateElement('bio-lifeforms', data.biosphere.life_forms_count);
                    }
                    
                    // Update geosphere data
                    if (data.geosphere.geological_activity !== undefined) {
                        updateElement('geo-activity', `${data.geosphere.geological_activity}/100`);
                        updateElement('geo-tectonic', data.geosphere.tectonic_active ? 'Yes' : 'No');
                        updateElement('geo-volcano', data.geosphere.volcanic_activity);
                    }
                })
                .catch(error => {
                    console.error('Error updating sphere data:', error);
                });
        }

        // Helper: Update element text content
        function updateElement(id, value) {
            const element = document.getElementById(id);
            if (element) element.textContent = value;
        }

        // Helper: Update progress bar width
        function updateProgressBar(id, percentage) {
            const element = document.getElementById(id);
            if (element) element.style.width = `${percentage}%`;
        }

        // Helper: Format mass for display
        function formatMass(mass) {
            if (mass > 1e18) return `${(mass / 1e18).toFixed(2)} Eg`;
            if (mass > 1e15) return `${(mass / 1e15).toFixed(2)} Pg`;
            if (mass > 1e12) return `${(mass / 1e12).toFixed(2)} Tg`;
            if (mass > 1e9) return `${(mass / 1e9).toFixed(2)} Gg`;
            return `${mass.toFixed(2)} kg`;
        }

        // Log to console panel
        function logConsole(message, type = 'info') {
            const console = document.getElementById('console');
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            line.textContent = `[${timestamp}] > ${message}`;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
            
            // Keep only last 50 messages
            while (console.children.length > 50) {
                console.removeChild(console.firstChild);
            }
        }

        // Setup layer toggles
        function setupLayerToggles() {
            document.querySelectorAll('.layer-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const layer = this.dataset.layer;
                    toggleLayer(layer);
                    updateLayerButtons();
                });
            });
        }

        // Layer visibility state - terrain ALWAYS visible as geological base
        let visibleLayers = new Set(['terrain']); // Terrain is permanent lithosphere base

        // Toggle layer visibility (ADDITIVE overlays, not exclusive modes)
        // SimEarth Behavior: Multiple layers can be active simultaneously
        function toggleLayer(layerName) {
            if (layerName === 'terrain') {
                // Terrain is the geological base (lithosphere) - cannot be turned off
                // Clicking it resets view to bare planet (removes all overlays)
                visibleLayers.clear();
                visibleLayers.add('terrain');
                logConsole('Reset to base terrain (bare planet lithosphere)', 'info');
            } else {
                // All other layers are ADDITIVE overlays on the base terrain
                if (visibleLayers.has(layerName)) {
                    // Remove this overlay
                    visibleLayers.delete(layerName);
                    logConsole(`${layerName} overlay hidden`, 'info');
                } else {
                    // Add this overlay (terrain stays visible underneath)
                    visibleLayers.add(layerName);
                    logConsole(`${layerName} overlay shown`, 'info');
                }
            }

            renderTerrainMap(); // Re-render with new layer configuration
            updateLayerButtons();
        }

        // Update button active states
        // Buttons show active when their layer is visible
        function updateLayerButtons() {
            document.querySelectorAll('.layer-btn').forEach(btn => {
                const layer = btn.dataset.layer;
                if (visibleLayers.has(layer)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }




        // Create a new sphere
        function createSphere(sphereType) {
            logConsole(`Creating ${sphereType}...`, 'info');
            
            fetch(`/admin/celestial_bodies/${planetId}/spheres`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
                },
                body: JSON.stringify({ 
                    sphere_type: sphereType,
                    sphere: { 
                        temperature: sphereType.includes('hydro') ? 300 : 200,
                        pressure: sphereType === 'atmosphere' ? 1.0 : 0,
                        thickness: sphereType === 'cryosphere' ? 10000 : null
                    }
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logConsole(`${sphereType} created successfully`, 'success');
                    location.reload(); // Refresh to show new sphere
                } else {
                    logConsole(`Failed to create ${sphereType}: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                logConsole(`Error creating ${sphereType}: ${error.message}`, 'error');
            });
        }

        // Edit an existing sphere
        function editSphere(sphereId, sphereType) {
            logConsole(`Editing ${sphereType}...`, 'info');
            // For now, redirect to a simple edit form
            // In a full implementation, this would open a modal
            window.location.href = `/admin/celestial_bodies/${planetId}/spheres/${sphereId}/edit?type=${sphereType}`;
        }

        // Delete a sphere
        function deleteSphere(sphereId, sphereType) {
            logConsole(`Deleting ${sphereType}...`, 'warning');
            
            fetch(`/admin/celestial_bodies/${planetId}/spheres/${sphereId}`, {
                method: 'DELETE',
                headers: {
                    'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logConsole(`${sphereType} deleted successfully`, 'success');
                    location.reload(); // Refresh to hide deleted sphere
                } else {
                    logConsole(`Failed to delete ${sphereType}: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                logConsole(`Error deleting ${sphereType}: ${error.message}`, 'error');
            });
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (updateInterval) clearInterval(updateInterval);
            window.monitorUpdateInterval = null;
        });

        // Store interval globally for cleanup
        window.monitorUpdateInterval = updateInterval;

        // Initialize map on page load
        window.addEventListener('load', () => {
            renderTerrainMap();
        });
        } // End of script execution check
    </script>
</body>
</html>
