<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="<%= form_authenticity_token %>">
    <title>Admin Monitor - <%= @celestial_body.name %></title>
    <%= stylesheet_link_tag 'admin/monitor', media: 'all' %>
</head>
<body>
    <div id="mainContainer">
        <!-- Header -->
        <div id="header">
            <h1 id="planetName"><%= @celestial_body.name %> - ADMIN MONITOR</h1>
            <div id="planetInfo">
                <%= @celestial_body.type %> | 
                Radius: <%= number_to_human(@celestial_body.radius, precision: 2) %> m | 
                Gravity: <%= number_with_precision(@celestial_body.gravity, precision: 3) %>g |
                Temp: <%= number_with_precision(@celestial_body.surface_temperature, precision: 1) %>K
            </div>
        </div>
        
        <!-- Left Panel: AI Mission Controls -->
        <div id="toolPanel">
            <!-- Mission Control Section -->
            <div class="tool-section">
                <h3>AI MISSION CONTROL</h3>
                <button class="tool-button" data-test="resource_extraction">
                    ‚õèÔ∏è Test Resource Extraction
                </button>
                <button class="tool-button" data-test="base_construction">
                    üèóÔ∏è Test Base Construction
                </button>
                <button class="tool-button" data-test="isru_pipeline">
                    üè≠ Test ISRU Pipeline
                </button>
                <button class="tool-button" onclick="window.location.href='/celestial_bodies/<%= @celestial_body.id %>'">
                    üëÅÔ∏è View Public Page
                </button>
                <button class="tool-button" onclick="window.location.href='/admin/celestial_bodies/<%= @celestial_body.id %>/edit'">
                    ‚öôÔ∏è Edit Celestial Body
                </button>
            </div>
            
            <!-- Management Tools Section -->
            <div class="tool-section">
                <h3>ADMIN TOOLS</h3>
                <button class="tool-button" onclick="window.location.href='/admin/celestial_bodies/<%= @celestial_body.id %>/edit'">
                    ‚öôÔ∏è Edit Celestial Body Properties
                </button>
                <button class="tool-button" onclick="window.location.href='/celestial_bodies/<%= @celestial_body.id %>'">
                    üëÅÔ∏è View Public Page
                </button>
            </div>
            
            <!-- Active Missions Section -->
            <div class="tool-section">
                <h3>ACTIVE MISSIONS</h3>
                <div id="missionList">
                    <% @ai_missions.each do |mission| %>
                        <div class="mission-item <%= mission[:status] %>">
                            <div class="mission-header">
                                <span class="mission-type"><%= mission[:type] %></span>
                                <span class="mission-status"><%= mission[:status].upcase %></span>
                            </div>
                            <div class="mission-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: <%= mission[:progress] %>%"></div>
                                </div>
                                <span class="progress-text"><%= mission[:progress] %>%</span>
                            </div>
                        </div>
                    <% end %>
                </div>
            </div>
            
            <!-- View Layers Section -->
            <div class="tool-section">
                <h3>MAP LAYERS</h3>
                <div class="layer-selector">
                    <button class="layer-btn active" data-layer="terrain">Terrain</button>
                    <button class="layer-btn active" data-layer="water">Water</button>
                    <button class="layer-btn active" data-layer="biomes">Biomes</button>
                    <button class="layer-btn" data-layer="features">Features</button>
                    <button class="layer-btn" data-layer="temperature">Temp</button>
                    <button class="layer-btn" data-layer="resources">Resources</button>
                </div>
            </div>
            
            <!-- Geological Features -->
            <% if @geological_features.any? %>
                <div class="tool-section">
                    <h3>GEOLOGICAL FEATURES</h3>
                    <div class="feature-list">
                        <% @geological_features.take(5).each do |feature| %>
                            <div class="feature-item">
                                <strong><%= feature[:name] %></strong>
                                <span class="feature-type"><%= feature[:type] %></span>
                            </div>
                        <% end %>
                    </div>
                </div>
            <% end %>
        </div>
        
        <!-- Center Panel: Planetary Map -->
        <div id="canvasWrapper">
            <div id="mapOverlay">
                <div id="mapTitle"><%= @celestial_body.name %> - PLANETARY MAP</div>
                <div id="mapControls">
                    <div class="control-group">
                        <label>Zoom: <span id="zoomValue" class="value-display">1.0x</span></label>
                        <input type="range" id="zoom" min="0.5" max="4" step="0.1" value="1">
                    </div>
                </div>
            </div>
            <canvas id="planetCanvas" width="800" height="400"></canvas>
            <div id="featureTooltip" class="hidden">
                <div id="tooltipContent"></div>
            </div>
        </div>
        
        <!-- Right Panel: Sphere Data -->
        <div id="dataPanel">
            <!-- Atmosphere Section -->
            <div class="data-section">
                <h3>ATMOSPHERE</h3>
                <% if @celestial_body.atmosphere %>
                    <div class="data-row">
                        <span class="data-label">Pressure:</span>
                        <span class="data-value" id="atmo-pressure">
                            <%= number_with_precision(@celestial_body.atmosphere.pressure, precision: 4) %> bar
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Temperature:</span>
                        <span class="data-value" id="atmo-temp">
                            <%= number_with_precision(@celestial_body.atmosphere.temperature, precision: 1) %> K
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Total Liquid Mass:</span>
                        <span class="data-value" id="atmo-mass">
                            <%= number_to_human(@celestial_body.atmosphere.total_atmospheric_mass || 0, precision: 2) %> kg
                        </span>
                    </div>
                    
                    <!-- Composition -->
                    <% composition = @celestial_body.atmospheric_composition %>
                    <% if composition.any? %>
                        <h4 class="subsection">Composition:</h4>
                        <% composition.each do |gas, percentage| %>
                            <div class="data-row">
                                <span class="data-label"><%= gas %>:</span>
                                <span class="data-value"><%= number_with_precision(percentage, precision: 2) %>%</span>
                            </div>
                        <% end %>
                    <% end %>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Hydrosphere Section -->
            <div class="data-section">
                <h3>HYDROSPHERE</h3>
                <% if @celestial_body.hydrosphere %>
                    <div class="data-row">
                        <span class="data-label">Liquid Coverage:</span>
                        <span class="data-value" id="hydro-coverage">
                            <%= number_with_precision(@celestial_body.hydrosphere.water_coverage || 0, precision: 1) %>%
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Ocean Mass:</span>
                        <span class="data-value" id="hydro-ocean">
                            <%= number_to_human(oceans_value(@celestial_body.hydrosphere.oceans), precision: 2) %> kg
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Ice Mass:</span>
                        <span class="data-value" id="hydro-ice">
                            <%= number_to_human(ice_caps_value(@celestial_body.hydrosphere.ice_caps), precision: 2) %> kg
                        </span>
                    </div>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Subsurface Hydrosphere Section -->
            <div class="data-section">
                <h3>SUBSURFACE HYDROSPHERE</h3>
                <% if @celestial_body.subsurface_hydrosphere %>
                    <div class="data-row">
                        <span class="data-label">Deep Ocean:</span>
                        <span class="data-value" id="subsurface-type">Liquid Layer</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Composition:</span>
                        <span class="data-value" id="subsurface-composition">
                            <%= @celestial_body.subsurface_hydrosphere.composition&.map { |k,v| "#{k}: #{v}%" }&.join(', ') || 'Unknown' %>
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Temperature:</span>
                        <span class="data-value" id="subsurface-temp">
                            <%= number_with_precision(@celestial_body.subsurface_hydrosphere.temperature, precision: 1) %> K
                        </span>
                    </div>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Cryosphere Section -->
            <div class="data-section">
                <h3>CRYOSPHERE</h3>
                <% if @celestial_body.cryosphere %>
                    <div class="data-row">
                        <span class="data-label">Shell Type:</span>
                        <span class="data-value" id="cryo-type">
                            <%= @celestial_body.cryosphere.shell_type&.humanize || 'Unknown' %>
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Thickness:</span>
                        <span class="data-value" id="cryo-thickness">
                            <%= @celestial_body.cryosphere.thickness ? "#{number_with_precision(@celestial_body.cryosphere.thickness / 1000.0, precision: 1)} km" : 'Unknown' %>
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Artificial:</span>
                        <span class="data-value" id="cryo-artificial">
                            <%= @celestial_body.cryosphere.artificial ? 'Yes' : 'No' %>
                        </span>
                    </div>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Biosphere Section -->
            <div class="data-section">
                <h3>BIOSPHERE</h3>
                <% if @celestial_body.biosphere %>
                    <div class="data-row">
                        <span class="data-label">Biodiversity:</span>
                        <span class="data-value" id="bio-diversity">
                            <%= number_with_precision((@celestial_body.biosphere.biodiversity_index || 0) * 100, precision: 1) %>%
                        </span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="bio-diversity-bar" 
                             style="width: <%= (@celestial_body.biosphere.biodiversity_index || 0) * 100 %>%"></div>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Habitability:</span>
                        <span class="data-value" id="bio-habitability">
                            <%= number_with_precision((@celestial_body.biosphere.habitable_ratio || 0) * 100, precision: 1) %>%
                        </span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="bio-habitability-bar" 
                             style="width: <%= (@celestial_body.biosphere.habitable_ratio || 0) * 100 %>%"></div>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Life Forms:</span>
                        <span class="data-value" id="bio-lifeforms">
                            <%= @celestial_body.biosphere.life_forms.count %>
                        </span>
                    </div>
                <% else %>
                    <div class="data-row">
                        <span class="data-value warning">Not Present</span>
                    </div>
                <% end %>
            </div>
            
            <!-- Geosphere Section -->
            <% if @celestial_body.geosphere %>
                <div class="data-section">
                    <h3>GEOSPHERE</h3>
                    <div class="data-row">
                        <span class="data-label">Geological Activity:</span>
                        <span class="data-value" id="geo-activity">
                            <%= number_with_precision((@celestial_body.geosphere.geological_activity || 0) * 100, precision: 1) %>%
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Tectonic Active:</span>
                        <span class="data-value" id="geo-tectonic">
                            <%= @celestial_body.geosphere.tectonic_activity ? 'Yes' : 'No' %>
                        </span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Core Mass:</span>
                        <span class="data-value" id="geo-core">
                            <%= number_to_human(@celestial_body.geosphere.total_core_mass || 0, precision: 2) %> kg
                        </span>
                    </div>
                </div>
            <% end %>
        </div>
        
        <!-- Bottom Panel: Console -->
        <div id="console">
            <div class="console-line info">&gt; Admin monitoring system initialized for <%= @celestial_body.name %></div>
            <div class="console-line info">&gt; Sphere data loaded: 
                <%= @sphere_summary.select { |k, v| v }.keys.join(', ') %>
            </div>
            <div class="console-line info">&gt; Ready for AI Manager testing operations</div>
        </div>
    </div>

    <script>
        // Admin monitoring interface JavaScript
        const planetId = <%= @celestial_body.id %>;
        let updateInterval = null;

        // Initialize monitoring
        document.addEventListener('DOMContentLoaded', function() {
            setupAITestButtons();
            setupLayerToggles();
            startDataPolling();
            logConsole('System initialized', 'info');
        });

        // Setup AI test buttons
        function setupAITestButtons() {
            document.querySelectorAll('.tool-button[data-test]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const testType = this.dataset.test;
                    runAITest(testType);
                });
            });
        }

        // Run AI Manager test
        function runAITest(testType) {
            logConsole(`Starting AI test: ${testType}`, 'info');
            
            fetch(`/admin/celestial_bodies/${planetId}/run_ai_test`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
                },
                body: JSON.stringify({ test_type: testType })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logConsole(data.message, 'success');
                    logConsole(`Test completed: ${JSON.stringify(data)}`, 'info');
                } else {
                    logConsole(`Test failed: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                logConsole(`Error running test: ${error.message}`, 'error');
            });
        }

        // Setup layer toggles
        function setupLayerToggles() {
            document.querySelectorAll('.layer-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const layer = this.dataset.layer;
                    logConsole(`Layer ${layer} ${this.classList.contains('active') ? 'enabled' : 'disabled'}`, 'info');
                });
            });
        }

        // Start polling for data updates
        function startDataPolling() {
            updateInterval = setInterval(updateSphereData, 5000); // Update every 5 seconds
        }

        // Update sphere data from server
        function updateSphereData() {
            fetch(`/admin/celestial_bodies/${planetId}/sphere_data`)
                .then(response => response.json())
                .then(data => {
                    // Update atmosphere data
                    if (data.atmosphere.pressure !== undefined) {
                        updateElement('atmo-pressure', `${data.atmosphere.pressure.toFixed(4)} bar`);
                        updateElement('atmo-temp', `${data.atmosphere.temperature.toFixed(1)} K`);
                        updateElement('atmo-mass', formatMass(data.atmosphere.total_mass));
                    }
                    
                    // Update hydrosphere data
                    if (data.hydrosphere.water_coverage !== undefined) {
                        updateElement('hydro-coverage', `${data.hydrosphere.water_coverage.toFixed(1)}%`);
                        updateElement('hydro-ocean', formatMass(data.hydrosphere.ocean_mass));
                        updateElement('hydro-ice', formatMass(data.hydrosphere.ice_mass));
                    }
                    
                    // Update biosphere data
                    if (data.biosphere.biodiversity_index !== undefined) {
                        updateElement('bio-diversity', `${data.biosphere.biodiversity_index.toFixed(1)}%`);
                        updateProgressBar('bio-diversity-bar', data.biosphere.biodiversity_index);
                        updateElement('bio-habitability', `${data.biosphere.habitable_ratio.toFixed(1)}%`);
                        updateProgressBar('bio-habitability-bar', data.biosphere.habitable_ratio);
                        updateElement('bio-lifeforms', data.biosphere.life_forms_count);
                    }
                    
                    // Update geosphere data
                    if (data.geosphere.geological_activity !== undefined) {
                        updateElement('geo-activity', `${data.geosphere.geological_activity}/100`);
                        updateElement('geo-tectonic', data.geosphere.tectonic_active ? 'Yes' : 'No');
                        updateElement('geo-volcano', data.geosphere.volcanic_activity);
                    }
                })
                .catch(error => {
                    console.error('Error updating sphere data:', error);
                });
        }

        // Helper: Update element text content
        function updateElement(id, value) {
            const element = document.getElementById(id);
            if (element) element.textContent = value;
        }

        // Helper: Update progress bar width
        function updateProgressBar(id, percentage) {
            const element = document.getElementById(id);
            if (element) element.style.width = `${percentage}%`;
        }

        // Helper: Format mass for display
        function formatMass(mass) {
            if (mass > 1e18) return `${(mass / 1e18).toFixed(2)} Eg`;
            if (mass > 1e15) return `${(mass / 1e15).toFixed(2)} Pg`;
            if (mass > 1e12) return `${(mass / 1e12).toFixed(2)} Tg`;
            if (mass > 1e9) return `${(mass / 1e9).toFixed(2)} Gg`;
            return `${mass.toFixed(2)} kg`;
        }

        // Log to console panel
        function logConsole(message, type = 'info') {
            const console = document.getElementById('console');
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            line.textContent = `[${timestamp}] > ${message}`;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
            
            // Keep only last 50 messages
            while (console.children.length > 50) {
                console.removeChild(console.firstChild);
            }
        }

        // Setup sphere management controls
        // Setup sphere management (hidden by default)




        // Create a new sphere
        function createSphere(sphereType) {
            logConsole(`Creating ${sphereType}...`, 'info');
            
            fetch(`/admin/celestial_bodies/${planetId}/spheres`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
                },
                body: JSON.stringify({ 
                    sphere_type: sphereType,
                    sphere: { 
                        temperature: sphereType.includes('hydro') ? 300 : 200,
                        pressure: sphereType === 'atmosphere' ? 1.0 : 0,
                        thickness: sphereType === 'cryosphere' ? 10000 : null
                    }
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logConsole(`${sphereType} created successfully`, 'success');
                    location.reload(); // Refresh to show new sphere
                } else {
                    logConsole(`Failed to create ${sphereType}: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                logConsole(`Error creating ${sphereType}: ${error.message}`, 'error');
            });
        }

        // Edit an existing sphere
        function editSphere(sphereId, sphereType) {
            logConsole(`Editing ${sphereType}...`, 'info');
            // For now, redirect to a simple edit form
            // In a full implementation, this would open a modal
            window.location.href = `/admin/celestial_bodies/${planetId}/spheres/${sphereId}/edit?type=${sphereType}`;
        }

        // Delete a sphere
        function deleteSphere(sphereId, sphereType) {
            logConsole(`Deleting ${sphereType}...`, 'warning');
            
            fetch(`/admin/celestial_bodies/${planetId}/spheres/${sphereId}`, {
                method: 'DELETE',
                headers: {
                    'X-CSRF-Token': document.querySelector('[name="csrf-token"]').content
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    logConsole(`${sphereType} deleted successfully`, 'success');
                    location.reload(); // Refresh to hide deleted sphere
                } else {
                    logConsole(`Failed to delete ${sphereType}: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                logConsole(`Error deleting ${sphereType}: ${error.message}`, 'error');
            });
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (updateInterval) clearInterval(updateInterval);
        });

        // Planetary Map Class
        class PlanetMap {
            constructor(canvasId, celestialBodyData) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.celestialBodyData = celestialBodyData;
                this.zoom = 1;
                this.mapData = null;
                this.terrainData = null; // Height map data
                this.tooltip = document.getElementById('featureTooltip');
                
                this.layers = {
                    terrain: true,
                    water: true,
                    biomes: true,
                    features: true,
                    temperature: false,
                    resources: false
                };
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.loadMapData();
                this.generateTerrain(); // Generate procedural terrain
            }
            
            setupEventListeners() {
                // Zoom control
                const zoomInput = document.getElementById('zoom');
                if (zoomInput) {
                    zoomInput.addEventListener('input', (e) => {
                        this.zoom = parseFloat(e.target.value);
                        document.getElementById('zoomValue').textContent = `${this.zoom.toFixed(1)}x`;
                        this.render();
                    });
                }
                
                // Canvas click and mouse move
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => this.hideTooltip());
                
                // Layer toggles
                document.querySelectorAll('.layer-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const layer = e.target.dataset.layer;
                        this.toggleLayer(layer);
                        e.target.classList.toggle('active');
                    });
                });
            }
            
            toggleLayer(layer) {
            generateTerrain() {
            renderTerrain() {
                if (!this.heightMap) return;
                const ctx = this.canvas.getContext('2d');
                const imageData = ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        const heightX = Math.floor((x / this.canvas.width) * this.heightMap[0].length);
                        const heightY = Math.floor((y / this.canvas.height) * this.heightMap.length);
                        const height = this.heightMap[heightY][heightX];
                        
                        const index = (y * this.canvas.width + x) * 4;
                        
                        // Terrain color based on height
                        if (height < 0.3) {
                            // Dee            renderTerrain() {
                ] = 0;     // R
                            data[index + 1] = 0; // G
                            data[index + 2] = 100; // B
                        } else if (height < 0.4) {
                            // Shallow water
                            data[index] = 0;     // R
                            data[index + 1] = 50;  // G
                            data[index + 2] = 150; // B
                        } else if (height < 0.6) {
                            // Land
                            data[index] = Math.floor(height * 100 + 50); // R
                            data[index + 1] = Math.floor(height * 150 + 100); // G
                            data[index + 2] = Math.floor(height * 50 + 50); // B
                        } else {
                            // Mountains
                            data[index] = Math.floor(height * 200); // R
                            data[index + 1] = Math.floor(height * 200); // G
                            data[index + 2] = Math.floor(height * 200); // B
                        }
                        data[index + 3] = 255; // A
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
                this.heightMap = [];
                const resolution = 200;
                for (let y = 0; y < resolution; y++) {
                    this.heightMap[y] = [];
                    for (let x = 0; x < resolution * 2; x++) {
                        this.heightMap[y][x] = Math.random();
                    }
                }
            }
            
            generateTerrain() {
            renderTerrain() {
                if (!this.heightMap) return;
                const ctx = this.canvas.getContext('2d');
                const imageData = ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        const heightX = Math.floor((x / this.canvas.width) * this.heightMap[0].length);
                        const heightY = Math.floor((y / this.canvas.height) * this.heightMap.length);
                        const height = this.heightMap[heightY][heightX];
                        
                        const index = (y * this.canvas.width + x) * 4;
                        
                        // Terrain color based on height
                        if (height < 0.3) {
                            // Dee            renderTerrain() {
                ] = 0;     // R
                            data[index + 1] = 0; // G
                            data[index + 2] = 100; // B
                        } else if (height < 0.4) {
                            // Shallow water
                            data[index] = 0;     // R
                            data[index + 1] = 50;  // G
                            data[index + 2] = 150; // B
                        } else if (height < 0.6) {
                            // Land
                            data[index] = Math.floor(height * 100 + 50); // R
                            data[index + 1] = Math.floor(height * 150 + 100); // G
                            data[index + 2] = Math.floor(height * 50 + 50); // B
                        } else {
                            // Mountains
                            data[index] = Math.floor(height * 200); // R
                            data[index + 1] = Math.floor(height * 200); // G
                            data[index + 2] = Math.floor(height * 200); // B
                        }
                        data[index + 3] = 255; // A
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
                // Generate terrain based on real planetary characteristics
                this.heightMap = [];
                const resolution = 200;
                const planetType = this.celestialBodyData.type ? this.celestialBodyData.type.toLowerCase() : 'terrestrial';
                const planetName = this.celestialBodyData.name ? this.celestialBodyData.name.toLowerCase() : 'unknown';
                
                // Base terrain characteristics by planet type
                let baseElevation = 0.5;
                let roughness = 0.3;
                let waterLevel = 0.3;
                let mountainDensity = 0.1;
                
                // Adjust characteristics based on planet type and name
                if (planetType === 'terrestrial') {
                    if (planetName.includes('earth')) {
                        // Earth-like terrain
                                  generateTerrain() {
            renderTerrain() {
                if (!this.heightMap) return;
                const ctx = this.canvas.getContext('2d');
                const imageData = ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        const heightX = Math.floor((x / this.canvas.width) * this.heightMap[0].length);
                        const heightY = Math.floor((y / this.canvas.height) * this.heightMap.length);
                        const height = this.heightMap[heightY][heightX];
                        
                        const index = (y * this.canvas.width + x) * 4;
                        
                        // Terrain color based on height
                        if (height < 0.3) {
                            // Dee            renderTerrain() {
                ] = 0;     // R
                            data[index + 1] = 0; // G
                            data[index + 2] = 100; // B
                        } else if (height < 0.4) {
                            // Shallow water
                            data[index] = 0;     // R
                            data[index + 1] = 50;  // G
                            data[index + 2] = 150; // B
                        } else if (height < 0.6) {
                            // Land
                            data[index] = Math.floor(height * 100 + 50); // R
                            data[index + 1] = Math.floor(height * 150 + 100); // G
                            data[index + 2] = Math.floor(height * 50 + 50); // B
                        } else {
                            // Mountains
                            data[index] = Math.floor(height * 200); // R
                            data[index + 1] = Math.floor(height * 200); // G
                            data[index + 2] = Math.floor(height * 200); // B
                        }
                        data[index + 3] = 255; // A
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
               roughness = 0.4;
                        waterLevel = 0.35;
                        mountainDensity = 0.15;
                    } else if (planetName.includes('mars')) {
                        // Mars-like terrain
                        baseElevation = 0.3;
                        roughness = 0.6;
                        waterLevel = 0.1;
                        mountainDensity = 0.25;
                    } else if (planetName.includes('venus')) {
                        // Venus-like terrain
                        baseElevation = 0.6;
                        roughness = 0.2;
                        waterLevel = 0.05;
                        mountainDensity = 0.3;
                    }
                } else if (planetType === 'gas_giant' || planetType === 'ice_giant') {
                    // Gas giants have no solid surface
                    baseElevation = 0.5;
                    roughness = 0.1;
                    waterLevel = 0.0;
                    mountainDensity = 0.0;
                }
                
                for (let y = 0; y < resolution; y++) {
                    this.heightMap[y] = [];
                    for (let x = 0; x < resolution * 2; x++) {
                        // Create realistic terrain based on planetary characteristics
                        const nx = x / resolution - 1;
                        const ny = y / resolution - 0.5;
                        
                        let height = baseElevation;
                        
                        // Add continental features
                        height += Math.sin(nx * Math.PI * 2) * Math.cos(ny * Math.PI) * roughness;
                        
                        // Add mountain ranges
                        if (Math.random() < mountainDensity) {
                            height += Math.sin(nx * Math.PI * 8) * Math.cos(ny * Math.PI * 4) * 0.3;
                        }
                        
                        // Add craters for rocky planets
                        if (planetType === 'terrestrial' && Math.random() < 0.05) {
                            const craterDepth = Math.random() * 0.2;
                            height -= craterDepth;
                        }
                        
                        // Normalize to 0-1
                        height = Math.max(0, Math.min(1, height));
                        this.heightMap[y][x] = height;
                    }
                }
            }
            
                this.layers[layer] = !this.layers[layer];
                this.render();
            }
            
            async loadMapData() {
                try {
                    const response = await fetch(`/celestial_bodies/${this.celestialBodyId}/geological_features`);
                    if (!response.ok) {
                        throw new Error('Failed to load geological features');
                    }
                    this.mapData = await response.json();
                    this.render();
                } catch (error) {
                    console.error('Error loading map data:', error);
                    document.getElementById('tileDetails').innerHTML = 
                        '<span style="color: #e94560">Error loading map data</span>';
                }
            }
            
            latLonToPixel(lat, lon) {
                // Equirectangular projection
                const x = ((lon + 180) / 360) * this.canvas.width;
                const y = ((90 - lat) / 180) * this.canvas.height;
                return { x, y };
            }
            
            pixelToLatLon(x, y) {
                const lat = 90 - (y / this.canvas.height) * 180;
                const lon = (x / this.canvas.width) * 360 - 180;
                return { lat, lon };
            }
            
            render() {
                if (!this.heightMap) this.generateTerrain();
                this.renderTerrain();
                
                // Generate terrain if not already generated
                if (!this.heightMap) {
                    this.generateTerrain();
                }
                
                // Render terrain base layer
                this.renderTerrain();
                
                // if (!this.mapData) return; // Commented out to allow terrain rendering
                
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid lines for reference
                this.drawGrid();
                
                // Draw features
                if (this.layers.lavaTubes && this.mapData.lava_tubes) {
                    this.drawFeatures(this.mapData.lava_tubes, '#00ffff');
                }
                
                if (this.layers.craters && this.mapData.craters) {
                    this.drawFe            render() {
                if (!this.heightMap) this.generateTerrain();
                this.renderTerrain();
                
              00');
                }
                
                if (this.layers.strategicSites && this.mapData.strategic_sites) {
                    this.drawFeatures(this.mapData.strategic_sites, '#ff00ff');
                }
                // if (!this.mapData) return; // Commented out to allow terrain rendering
                
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid lines for reference
                this.drawGrid();
                
                // Draw features
                if (this.layers.lavaTubes && this.mapData.lava_tubes) {
                    this.drawFeatures(this.mapData.lava_tubes, '#00ffff');
                }
                
                if (this.layers.craters && this.mapData.craters) {
                    this.drawFeatures(this.mapData.craters, '#ffff00');
                }
                
                if (this.layers.strategicSites && this.mapData.strategic_sites) {
                    this.drawFeatures(this.mapData.strategic_sites, '#ff00ff');
                }
            }
            
            drawGrid() {
                this.ctx.strokeStyle = '#1a1a3e';
                this.ctx.lineWidth = 1;
                
                // Latitude lines (every 30 degrees)
                for (let lat = -90; lat <= 90; lat += 30) {
                    const start = this.latLonToPixel(lat, -180);
                    const end = this.latLonToPixel(lat, 180);
                    this.ctx.beginPath();
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(end.x, end.y);
                    this.ctx.stroke();
                }
                
                // Longitude lines (every 30 degrees)
                for (let lon = -180; lon <= 180; lon += 30) {
                    const start = this.latLonToPixel(-90, lon);
                    const end = this.latLonToPixel(90, lon);
                    this.ctx.beginPath();
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(end.x, end.y);
                    this.ctx.stroke();
                }
            }
            
            drawFeatures(features, defaultColor) {
                features.forEach(feature => {
                    if (!feature.lat || !feature.lon) return;
                    
                    const pos = this.latLonToPixel(feature.lat, feature.lon);
                    
                    // Determine color based on priority
                    let color = defaultColor;
                    if (feature.priority === 'critical') color = '#ff00ff';
                    else if (feature.priority === 'high') color = '#00ff00';
                    else if (feature.priority === 'medium') color = '#ffff00';
                    
                    // Draw marker
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, 5 * this.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw border
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                    
                    // Draw label for high-priority features
                    if (feature.priority === 'critical' || feature.priority === 'high') {
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = `${10 * this.zoom}px Arial`;
                        this.ctx.fillText(feature.name, pos.x + 8, pos.y + 4);
                    }
                });
            }
            
            handleClick(event) {
                // if (!this.mapData) return; // Commented out to allow terrain rendering
                
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Check all features for clicks
                const clickedFeature = this.findFeatureAtPoint(x, y);
                
                if (clickedFeature) {
                    this.showFeatureInfo(clickedFeature);
                } else {
                    const coords = this.pixelToLatLon(x, y);
                    document.getElementById('tileDetails').innerHTML = 
                        `<strong>Coordinates:</strong><br>` +
                        `Lat: ${coords.lat.toFixed(2)}¬∞<br>` +
                        `Lon: ${coords.lon.toFixed(2)}¬∞`;
                }
            }
            
            findFeatureAtPoint(x, y) {
                const threshold = 10 * this.zoom; // Click detection radius
                
                const allFeatures = [
                    ...(this.layers.lavaTubes ? this.mapData.lava_tubes : []),
                    ...(this.layers.craters ? this.mapData.craters : []),
                    ...(this.layers.strategicSites ? this.mapData.strategic_sites : [])
                ];
                
                for (const feature of allFeatures) {
                    if (!feature.lat || !feature.lon) continue;
                    
                    const pos = this.latLonToPixel(feature.lat, feature.lon);
                    const distance = Math.sqrt((pos.x - x) ** 2 + (pos.y - y) ** 2);
                    
                    if (distance <= threshold) {
                        return feature;
                    }
                }
                
                return null;
            }
            
            showFeatureInfo(feature) {
                let html = `
                    <strong>${feature.name}</strong><br>
                    <strong>Type:</strong> ${feature.type}<br>
                    <strong>Coordinates:</strong> ${feature.lat.toFixed(2)}¬∞, ${feature.lon.toFixed(2)}¬∞<br>
                    <strong>Priority:</strong> <span style="color: ${this.getPriorityColor(feature.priority)}">${feature.priority || 'N/A'}</span><br>
                `;
                
                if (feature.dimensions) {
                    html += `<br><strong>Dimensions:</strong><br>`;
                    if (feature.dimensions.diameter_m) {
                        html += `Diameter: ${feature.dimensions.diameter_m.toLocaleString()} m<br>`;
                    }
                    if (feature.dimensions.depth_m) {
                        html += `Depth: ${feature.dimensions.depth_m.toLocaleString()} m<br>`;
                    }
                    if (feature.dimensions.estimated_volume_m3) {
                        html += `Volume: ${(feature.dimensions.estimated_volume_m3 / 1000000).toFixed(2)} million m¬≥<br>`;
                    }
                }
                
                if (feature.resources) {
                    html += `<br><strong>Resources:</strong><br>`;
                    Object.entries(feature.resources).forEach(([key, value]) => {
                        html += `${key}: ${value.toLocaleString()}<br>`;
                    });
                }
                
                if (feature.strategic_value && feature.strategic_value.length > 0) {
                    html += `<br><strong>Strategic Value:</strong><br>`;
                    feature.strategic_value.forEach(value => {
                        html += `‚Ä¢ ${value}<br>`;
                    });
                }
                
                document.getElementById('tileDetails').innerHTML = html;
            }
            
            getPriorityColor(priority) {
                switch(priority) {
                    case 'critical': return '#ff00ff';
                    case 'high': return '#00ff00';
                    case 'medium': return '#ffff00';
                    default: return '#aaa';
                }
            }
        }

        // Initialize map on page load
        window.addEventListener('load', () => {
            const celestialBodyId = <%= @celestial_body.id %>;
            new PlanetMap('planetCanvas', { id: celestialBodyId });
        });
    </script>
</body>
</html>
