document.addEventListener('DOMContentLoaded', function() {
  console.log('Game interface loaded');
  
  // System state
  let gameSpeed = 3; // Default simulation speed (1-5)
  let gamePaused = true;
  let gameTime = { year: 0, day: 0 };
  let lastUpdate = Date.now();
  
  // Debug output
  const systemCanvas = document.getElementById('systemCanvas');
  if (systemCanvas && systemCanvas.dataset.planets) {
    try {
      console.log("Raw planets data:", systemCanvas.dataset.planets);
      const planets = JSON.parse(systemCanvas.dataset.planets);
      console.log(`Loaded ${planets.length} celestial bodies:`);
      planets.forEach(p => {
        console.log(`${p.name} (${p.type}): is_moon=${p.is_moon}, category=${p.body_category}`);
      });
    } catch (e) {
      console.error('Error parsing planet data:', e);
      console.log("Raw data that failed to parse:", systemCanvas.dataset.planets);
    }
  } else {
    console.warn('No planet data found on canvas');
  }
  
  // System View Canvas
  if (!systemCanvas) return; // Exit if canvas doesn't exist
  
  const systemCtx = systemCanvas.getContext('2d');
  
  // Load actual planet data
  let celestialBodies = [];
  try {
    if (systemCanvas.dataset.planets) {
      celestialBodies = JSON.parse(systemCanvas.dataset.planets);
      console.log("Loaded celestial bodies:", celestialBodies);
    }
  } catch (e) {
    console.error("Error parsing planets data:", e);
  }
  
  // Resize canvas to fit container
  function resizeSystemCanvas() {
    const container = systemCanvas.parentElement;
    systemCanvas.width = container.clientWidth;
    systemCanvas.height = container.clientHeight;
    renderSystemView();
  }
  
  // Initial resize and add listener
  resizeSystemCanvas();
  window.addEventListener('resize', resizeSystemCanvas);
  
  // Simulation control buttons
  const runSimBtn = document.getElementById('run-sim');
  const pauseSimBtn = document.getElementById('pause-sim');
  const simSpeedSlider = document.getElementById('sim-speed-slider');
  const timeDisplay = document.querySelector('.current-time');
  
  if (runSimBtn) {
    runSimBtn.addEventListener('click', function() {
      gamePaused = false;
      this.textContent = "Running...";
      lastUpdate = Date.now();
      updateTimeDisplay();
    });
  }
  
  if (pauseSimBtn) {
    pauseSimBtn.addEventListener('click', function() {
      gamePaused = true;
      if (runSimBtn) runSimBtn.textContent = "Run Simulation";
      updateTimeDisplay();
    });
  }
  
  if (simSpeedSlider) {
    simSpeedSlider.addEventListener('input', function() {
      gameSpeed = parseInt(this.value);
    });
  }
  
  // Helper functions
  function drawStars(ctx, width, height) {
    ctx.fillStyle = '#FFF';
    for (let i = 0; i < 200; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const size = Math.random() * 2;
      ctx.fillRect(x, y, size, size);
    }
  }
  
  function drawSun(ctx, x, y) {
    const sunRadius = 40;
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, sunRadius);
    gradient.addColorStop(0, 'rgba(255, 255, 0, 1)');
    gradient.addColorStop(0.7, 'rgba(255, 165, 0, 1)');
    gradient.addColorStop(1, 'rgba(255, 69, 0, 0.5)');
    
    ctx.beginPath();
    ctx.arc(x, y, sunRadius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
  }
  
  // Update game time based on real time elapsed and game speed
  function updateGameTime() {
    if (gamePaused) return;
    
    const now = Date.now();
    const elapsed = (now - lastUpdate) / 1000; // seconds
    lastUpdate = now;
    
    // Convert to game days (speed 3 = 1 day per second)
    const daysPassed = elapsed * gameSpeed;
    gameTime.day += daysPassed;
    
    // Check if a year has passed (365 days)
    if (gameTime.day >= 365) {
      gameTime.year += Math.floor(gameTime.day / 365);
      gameTime.day = gameTime.day % 365;
    }
    
    updateTimeDisplay();
  }
  
  function updateTimeDisplay() {
    if (timeDisplay) {
      timeDisplay.textContent = `Year: ${Math.floor(gameTime.year)} | Day: ${Math.floor(gameTime.day)}`;
    }
  }
  
  // Render solar system
  function renderSystemView() {
    // Update game time
    updateGameTime();
    
    // Clear canvas
    systemCtx.fillStyle = '#000';
    systemCtx.fillRect(0, 0, systemCanvas.width, systemCanvas.height);
    
    // Draw starfield background
    drawStars(systemCtx, systemCanvas.width, systemCanvas.height);
    
    // Draw sun at center
    const centerX = systemCanvas.width / 2;
    const centerY = systemCanvas.height / 2;
    drawSun(systemCtx, centerX, centerY);
    
    // Draw planets if we have data
    if (celestialBodies && celestialBodies.length > 0) {
      drawPlanets(systemCtx, centerX, centerY, celestialBodies);
    } else {
      // Show message if no planets
      systemCtx.fillStyle = 'white';
      systemCtx.font = '16px Arial';
      systemCtx.textAlign = 'center';
      systemCtx.fillText('No celestial bodies found. Please run the seed data.', centerX, centerY + 100);
    }
  }
  
  function drawPlanets(ctx, centerX, centerY, bodies) {
    console.log("Drawing planets from bodies:", bodies);
    
    // Filter out moons (they will be drawn with their parent planets)
    const planets = bodies.filter(body => !body.is_moon);
    console.log(`Found ${planets.length} planets (non-moons)`);
    
    // Sort by orbital period (if available) or just use index
    planets.sort((a, b) => {
      if (a.orbital_period && b.orbital_period) {
        return parseFloat(a.orbital_period) - parseFloat(b.orbital_period);
      }
      return 0;
    });
    
    // Calculate scale for orbit radius
    const maxOrbit = Math.min(centerX, centerY) * 0.85;
    
    planets.forEach((planet, index) => {
      // Calculate orbit radius based on orbital period
      const orbitRadius = 80 + ((maxOrbit - 80) * (index + 1) / (planets.length + 1));
      
      // Calculate planet size based on radius or mass
      let planetSize = 10;
      if (planet.radius) {
        // Radius is stored in meters, scale it down for visualization
        planetSize = 5 + Math.log10(parseFloat(planet.radius) / 1000) * 3;
      } else if (planet.mass) {
        // Use mass as a fallback for size
        planetSize = 5 + Math.log10(parseFloat(planet.mass) / 1e23) * 2;
      } else {
        // Default scaling by position
        planetSize = 5 + (index * 3);
      }
      
      // Determine color based on body type and temperature
      let color;
      if (planet.body_category === 'terrestrial_planet') {
        // Terrestrial planets - color based on temperature
        const temp = parseFloat(planet.surface_temperature || 300);
        if (temp > 700) color = '#e74c3c'; // Hot (Venus)
        else if (temp > 350) color = '#e67e22'; // Warm
        else if (temp > 250) color = '#3498db'; // Earth-like
        else color = '#95a5a6'; // Cold (Mars)
      } else if (planet.body_category === 'gas_giant') {
        color = '#f39c12'; // Gas giants are orange-yellow
      } else if (planet.body_category === 'ice_giant') {
        color = '#3498db'; // Ice giants are blue
      } else {
        // Default colors by position
        const colors = ['#bbb', '#e7a963', '#3498db', '#e74c3c', '#e67e22'];
        color = colors[index % colors.length];
      }
      
      // Draw orbit
      ctx.beginPath();
      ctx.arc(centerX, centerY, orbitRadius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.stroke();
      
      // Calculate position based on game time instead of real time
      // This way animation stops when game is paused
      const orbitDuration = parseFloat(planet.orbital_period) || 365;
      let angle;
      
      if (gamePaused) {
        // When paused, position based on initial orbital position
        angle = (index * (Math.PI / 4)) % (Math.PI * 2); // Spread planets out
      } else {
        // When running, position based on game time
        const totalDays = (gameTime.year * 365) + gameTime.day;
        angle = ((totalDays % orbitDuration) / orbitDuration) * (Math.PI * 2);
      }
      
      const x = centerX + Math.cos(angle) * orbitRadius;
      const y = centerY + Math.sin(angle) * orbitRadius;
      
      // Draw planet
      ctx.beginPath();
      ctx.arc(x, y, planetSize, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      
      // Draw name
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(planet.name, x, y - planetSize - 10);
      
      // Find and draw moons for this planet
      const moons = bodies.filter(body => 
        body.is_moon && 
        body.parent_body && 
        body.parent_body.id === planet.id
      );
      
      moons.forEach((moon, moonIndex) => {
        const moonOrbitRadius = planetSize * 2 + (moonIndex * 5);
        const moonSize = Math.max(2, planetSize * 0.3);
        
        // Calculate moon position based on game time
        const moonOrbitDuration = parseFloat(moon.orbital_period) || 30;
        let moonAngle;
        
        if (gamePaused) {
          moonAngle = (moonIndex * (Math.PI / 2)) % (Math.PI * 2);
        } else {
          const totalDays = (gameTime.year * 365) + gameTime.day;
          moonAngle = ((totalDays % moonOrbitDuration) / moonOrbitDuration) * (Math.PI * 2);
        }
        
        const moonX = x + Math.cos(moonAngle) * moonOrbitRadius;
        const moonY = y + Math.sin(moonAngle) * moonOrbitRadius;
        
        // Draw moon orbit
        ctx.beginPath();
        ctx.arc(x, y, moonOrbitRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.stroke();
        
        // Draw moon
        ctx.beginPath();
        ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);
        ctx.fillStyle = '#ddd';
        ctx.fill();
        
        // Draw moon name
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(moon.name, moonX, moonY - moonSize - 5);
      });
    });
  }
  
  // Initial render
  renderSystemView();
  
  // Animate only at a reasonable framerate (30fps is plenty for this visualization)
  setInterval(renderSystemView, 33);
  
  // Initialize UI state
  updateTimeDisplay();
  
  // Run server-side simulation when clicking Run button
  async function runServerSimulation(days) {
    try {
      const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
      const response = await fetch('/game/run_simulation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken
        },
        body: JSON.stringify({
          days: days
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Update local game time with server time
        gameTime.year = data.time.year;
        gameTime.day = data.time.day;
        
        // Update the display
        updateTimeDisplay();
        
        // Add notification message
        if (data.message) {
          addNotification(data.message);
        }
      }
    } catch (error) {
      console.error('Error running simulation:', error);
    }
  }

  function addNotification(message) {
    const feed = document.getElementById('notification-feed');
    if (feed) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      feed.prepend(notification);
      
      // Limit notifications
      if (feed.children.length > 5) {
        feed.removeChild(feed.lastChild);
      }
    }
  }
});