# lib/tasks/ai_manager.rake

namespace :ai_manager do
  desc "Analyze all mission profiles and extract patterns"
  task analyze_mission_profiles: :environment do
    puts "\nğŸ” Analyzing Mission Profiles..."
    
    patterns = AIManager::MissionProfileAnalyzer.analyze_all_mission_profiles
    
    puts "\nâœ… Analysis Complete!"
    puts "   Patterns extracted: #{patterns.count}"
    
    patterns.each do |pattern_id, pattern|
      puts "\n#{pattern_id}:"
      puts "  Source: #{pattern[:source_file]}"
      puts "  Phases: #{pattern[:phase_structure][:total_phases]}"
      puts "  Duration: #{pattern[:phase_structure][:estimated_total_duration]} hours"
      puts "  Cost: #{pattern[:economic_model][:estimated_gcc_cost]} GCC"
      if pattern[:economic_model][:import_ratio]
        puts "  Import Ratio: #{(pattern[:economic_model][:import_ratio] * 100).round(1)}%"
      else
        puts "  Import Ratio: N/A"
      end
    end
    
    puts "\nğŸ’¾ Patterns saved to: data/json-data/ai-manager/learned_patterns.json"
  end
  
  desc "Compare mission profile patterns to find similarities"
  task compare_patterns: :environment do
    require Rails.root.join('app/services/ai_manager/mission_profile_analyzer')
    
    puts "\nğŸ” Comparing Mission Profile Patterns..."
    
    similarities = AIManager::PatternComparator.find_similar_patterns
    
    puts "\nğŸ“Š Pattern Similarities Analysis:"
    similarities.each do |category, patterns|
      puts "\n#{category.to_s.humanize}:"
      if patterns.any?
        patterns.each { |pattern| puts "  â€¢ #{pattern}" }
      else
        puts "  (No patterns found)"
      end
    end
    
    puts "\nğŸ’¡ Insights:"
    puts "  â€¢ #{similarities[:atmospheric_harvesting].count} patterns use atmospheric harvesting"
    puts "  â€¢ #{similarities[:orbital_construction].count} patterns include orbital construction"
    puts "  â€¢ #{similarities[:isru_focused].count} patterns are 100% ISRU-focused"
    puts "  â€¢ #{similarities[:cycler_dependent].count} patterns depend on cycler networks"
  end
  
  desc "Validate all patterns against game rules and physics"
  task validate_patterns: :environment do
    puts "\nğŸ” Validating All Mission Profile Patterns..."

    patterns_path = Rails.root.join('data', 'json-data', 'ai-manager', 'mission_profile_patterns.json')

    unless File.exist?(patterns_path)
      puts "   âŒ Pattern file not found: #{patterns_path}"
      puts "   Run 'rake ai_manager:extract_test_scenarios' first"
      next
    end

    patterns = JSON.parse(File.read(patterns_path))
    validator = AIManager::PatternValidator.new

    validation_results = {}
    summary = { total: patterns.count, validated: 0, experimental: 0, needs_review: 0, invalid: 0 }

    patterns.each do |pattern_id, pattern|
      puts "\n#{pattern_id}:"
      validation = validator.validate_pattern(pattern.symbolize_keys)

      puts "  Status: #{validation[:status].to_s.humanize}"
      puts "  Confidence: #{(validation[:confidence] * 100).round}%"

      if validation[:warnings].any?
        puts "  âš ï¸  Warnings:"
        validation[:warnings].each { |w| puts "    - #{w[:message]}" }
      end

      if validation[:errors].any?
        puts "  âŒ Errors:"
        validation[:errors].each { |e| puts "    - #{e[:message]}" }
      end

      # Update pattern with validation results
      pattern['status'] = validation[:status]
      pattern['confidence_score'] = validation[:confidence]
      pattern['validation_result'] = {
        valid: validation[:valid],
        warnings: validation[:warnings],
        errors: validation[:errors]
      }

      validation_results[pattern_id] = validation

      # Update summary
      case validation[:status]
      when :validated
        summary[:validated] += 1
      when :experimental
        summary[:experimental] += 1
      when :needs_review
        summary[:needs_review] += 1
      when :invalid
        summary[:invalid] += 1
      end
    end

    # Save updated patterns with validation results
    File.write(patterns_path, JSON.pretty_generate(patterns))

    puts "\nğŸ“Š Validation Summary:"
    puts "   Total patterns: #{summary[:total]}"
    puts "   âœ… Validated: #{summary[:validated]}"
    puts "   ğŸ§ª Experimental: #{summary[:experimental]}"
    puts "   âš ï¸  Needs review: #{summary[:needs_review]}"
    puts "   âŒ Invalid: #{summary[:invalid]}"

    puts "\nğŸ’¾ Updated patterns saved with validation status"
  end

  desc "Validate patterns with world-specific knowledge and suggest augmentations"
  task validate_patterns_world_aware: :environment do
    puts "\nğŸŒ World-Aware Pattern Validation..."

    patterns_path = GalaxyGame::Paths::AI_MISSION_PATTERNS_PATH

    unless File.exist?(patterns_path)
      puts "   âŒ Pattern file not found: #{patterns_path}"
      puts "   Run 'rake ai_manager:extract_test_scenarios' first"
      next
    end

    patterns = JSON.parse(File.read(patterns_path))

    # Load celestial bodies from Sol system for testing
    sol_system_path = Rails.root.join('data', 'json-data', 'star_systems', 'sol-complete.json')
    # Load celestial bodies from Sol system for testing
    sol_system_path = Rails.root.join('data', 'json-data', 'star_systems', 'sol-complete.json')
    celestial_bodies = if File.exist?(sol_system_path)
                        JSON.parse(File.read(sol_system_path))['celestial_bodies'] || []
                      else
                        []
                      end

    # Test with available celestial bodies
    test_bodies = celestial_bodies.select do |body|
      ['mars', 'venus', 'luna', 'titan', 'earth'].include?(body['name']&.downcase)
    end

    test_bodies.each do |body|
      world_name = body['name'].upcase
      puts "\nğŸ­ Validating for #{world_name}..."

      validator = AIManager::PatternValidator.new(body)
      world_results = { augmented: 0, improved: 0, unchanged: 0 }

      patterns.each do |pattern_id, pattern|
        original_validation = validator.validate_pattern(pattern.symbolize_keys)
        augmented_pattern = validator.augment_pattern(pattern.symbolize_keys)

        # Check if augmentation improved the pattern
        if augmented_pattern[:suggested_isru_additions].present?
          world_results[:augmented] += 1
          puts "   #{pattern_id}: Augmented with ISRU suggestions"
        elsif augmented_pattern[:production_capabilities].present?
          world_results[:improved] += 1
          puts "   #{pattern_id}: Enhanced with production capabilities"
        else
          world_results[:unchanged] += 1
        end

        # Update pattern with world-specific data
        pattern["world_#{body['name'].downcase}_validation"] = {
          validation_result: original_validation,
          augmented_data: augmented_pattern.except(:equipment_requirements, :phase_structure, :economic_model),
          compatibility_score: validator.assess_world_compatibility(pattern.symbolize_keys)[:score]
        }
      end

      puts "   ğŸ“Š #{world_name} Results:"
      puts "      Augmented: #{world_results[:augmented]}"
      puts "      Improved: #{world_results[:improved]}"
      puts "      Unchanged: #{world_results[:unchanged]}"
    end

    # Save updated patterns with world-aware validation
    File.write(patterns_path, JSON.pretty_generate(patterns))

    puts "\nğŸ’¾ Patterns updated with world-specific validation and augmentation data"
    puts "   AI can now make intelligent assumptions based on local resource availability!"
  end

  desc "Extract training scenarios from RSpec tests and integrate into AI learning"
  task extract_test_scenarios: :environment do
    puts "\nğŸ§ª Extracting Test Scenarios for AI Training..."

    # Extract scenarios from test mocks
    scenarios = AIManager::TestScenarioExtractor.extract_training_scenarios

    # Extract patterns from mission files (including manifests)
    mission_patterns = AIManager::TestScenarioExtractor.extract_patterns_from_missions

    # Convert test scenarios to training format
    training_data = AIManager::TestScenarioExtractor.convert_to_training_format(scenarios)

    # Load existing patterns
    patterns_path = GalaxyGame::Paths::AI_MISSION_PATTERNS_PATH
    existing_patterns = File.exist?(patterns_path) ? JSON.parse(File.read(patterns_path)) : {}

    # Add test-derived patterns
    training_data.each_with_index do |scenario, index|
      pattern_id = "test_scenario_#{index + 1}"
      existing_patterns[pattern_id] = {
        pattern_id: pattern_id,
        source: 'rspec_test_extraction',
        confidence: scenario[:confidence_score],
        settlement_state_requirements: scenario[:input_state],
        recommended_decision: scenario[:output_decision],
        success_criteria: scenario[:reward_function],
        extracted_at: Time.current.iso8601
      }
    end

    # Add mission-derived patterns
    mission_patterns.each do |pattern|
      existing_patterns[pattern[:pattern_id]] = pattern
    end

    # Save enhanced patterns
    File.write(patterns_path, JSON.pretty_generate(existing_patterns))

    puts "\nâœ… Test Scenario Integration Complete!"
    puts "   Test scenarios extracted: #{scenarios.count}"
    puts "   Mission patterns extracted: #{mission_patterns.count}"
    puts "   Total patterns now available: #{existing_patterns.count}"
    puts "   File saved: #{patterns_path}"

    # Validate the AI can use the new patterns
    puts "\nğŸ” Validating AI Integration..."
    if File.exist?(patterns_path)
      loaded_data = JSON.parse(File.read(patterns_path))
      puts "   âœ… AI pattern file contains #{loaded_data.count} patterns"
      test_scenarios = loaded_data.count {|k,v| v['source'] == 'rspec_test_extraction'}
      mission_patterns = loaded_data.count {|k,v| v['learned_from'] == 'mission_json_analysis'}
      puts "   ğŸ“Š Test scenarios integrated: #{test_scenarios}"
      puts "   ğŸ“Š Mission patterns integrated: #{mission_patterns}"
    else
      puts "   âŒ Pattern file not found"
    end
  end

  desc "Analyze AI performance and generate tuning recommendations"
  task analyze_performance: :environment do
    puts "\nğŸ“Š Analyzing AI Performance Across All Settlements..."

    performance_files = Dir.glob(Rails.root.join('data', 'json-data', 'ai-manager', 'performance_*.json'))

    if performance_files.empty?
      puts "   No performance data found. Run some AI decisions first."
      next
    end

    total_decisions = 0
    total_success_rate = 0.0
    pattern_stats = {}
    lessons_learned = []

    performance_files.each do |file|
      data = JSON.parse(File.read(file))
      settlement_id = data['settlement_id']

      puts "\nğŸ›ï¸ Settlement #{settlement_id}:"
      puts "   Decisions made: #{data['decision_history']&.size || 0}"

      if data['decision_history']&.any?
        decisions = data['decision_history']
        successful = decisions.count { |d| (d['success_score'] || 0) > 0.7 }
        success_rate = successful.to_f / decisions.size

        puts "   Success rate: #{(success_rate * 100).round(1)}%"
        puts "   Top patterns used: #{data['pattern_performance']&.keys&.first(3)&.join(', ') || 'none'}"

        total_decisions += decisions.size
        total_success_rate += success_rate

        lessons_learned.concat(decisions.flat_map { |d| d['lessons_learned'] || [] })

        # Aggregate pattern stats
        (data['pattern_performance'] || {}).each do |pattern, stats|
          pattern_stats[pattern] ||= { total_uses: 0, total_successes: 0 }
          pattern_stats[pattern][:total_uses] += stats['uses'] || 0
          pattern_stats[pattern][:total_successes] += stats['successes'] || 0
        end
      end
    end

    puts "\nğŸ“ˆ Overall Performance:"
    puts "   Total decisions across all settlements: #{total_decisions}"
    puts "   Average success rate: #{total_decisions > 0 ? ((total_success_rate / performance_files.size) * 100).round(1) : 0}%"

    puts "\nğŸ¯ Pattern Performance Rankings:"
    pattern_stats.sort_by { |_, stats| stats[:total_successes].to_f / stats[:total_uses] }.reverse.first(5).each do |pattern, stats|
      success_rate = stats[:total_successes].to_f / stats[:total_uses]
      puts "   #{pattern}: #{(success_rate * 100).round(1)}% success (#{stats[:total_uses]} uses)"
    end

    puts "\nğŸ§  Key Lessons Learned:"
    lesson_counts = lessons_learned.group_by(&:itself).transform_values(&:size).sort_by(&:last).reverse
    lesson_counts.first(5).each do |lesson, count|
      puts "   #{lesson}: #{count} occurrences"
    end

    puts "\nğŸ’¡ Tuning Recommendations:"
    if total_decisions > 0
      avg_success = total_success_rate / performance_files.size
      if avg_success < 0.6
        puts "   âš ï¸  Low success rate detected. Consider:"
        puts "      - Reviewing pattern matching logic"
        puts "      - Adjusting priority thresholds"
        puts "      - Adding more training scenarios"
      elsif avg_success > 0.9
        puts "   âœ… High performance! Consider:"
        puts "      - Increasing automation confidence"
        puts "      - Expanding to more complex scenarios"
      end
    end
  end

  desc "Apply AI behavior tuning based on performance data"
  task tune_ai_behavior: :environment do
    puts "\nğŸ”§ Tuning AI Behavior Based on Performance Data..."

    # Create a mock settlement for testing
    mock_settlement = OpenStruct.new(id: 999)

    # Initialize AI Manager
    ai_manager = AIManager::OperationalManager.new(mock_settlement)

    # Apply tuning
    ai_manager.tune_behavior

    puts "   âœ… Behavior tuning applied"
    puts "   ğŸ“Š Performance report:"
    report = ai_manager.get_performance_report
    puts "      Total decisions: #{report[:total_decisions]}"
    puts "      Success rate: #{(report[:success_rate] * 100).round(1)}%"
    puts "      Top patterns: #{report[:top_performing_patterns]&.first(3)&.map(&:first)&.join(', ') || 'none'}"
  end

  desc "Simulate AI adaptation in a test universe"
  task simulate_adaptation: :environment do
    puts "\nğŸ® Simulating AI Adaptation in Test Universe..."

    # Create test settlement using OpenStruct
    test_settlement = OpenStruct.new(id: 'simulation_001')

    # Initialize AI with fresh learning
    ai_manager = AIManager::OperationalManager.new(test_settlement)

    # Simulate a series of decisions and outcomes
    scenarios = [
      { context: { oxygen_level: 15, debt_level: 10000 }, expected_action: :emergency_procurement, outcome: :success, score: 0.9 },
      { context: { water_level: 25, debt_level: 5000 }, expected_action: :resource_procurement, outcome: :partial_success, score: 0.6 },
      { context: { oxygen_level: 85, water_level: 80, debt_level: 0 }, expected_action: :expansion, outcome: :success, score: 0.95 },
      { context: { oxygen_level: 20, debt_level: 20000 }, expected_action: :emergency_procurement, outcome: :failure, score: 0.2 },
      { context: { oxygen_level: 85, water_level: 80, debt_level: 0 }, expected_action: :expansion, outcome: :success, score: 0.9 }
    ]

    puts "   Running #{scenarios.size} simulated decision cycles..."

    scenarios.each_with_index do |scenario, index|
      puts "   Cycle #{index + 1}: #{scenario[:expected_action]}"

      # Record decision (simulated)
      decision = { action: scenario[:expected_action], reason: "simulation" }
      record = ai_manager.send(:record_decision_with_context, decision, scenario[:context], :simulation)

      # Record outcome
      ai_manager.send(:record_decision_outcome, scenario[:score], { outcome: scenario[:outcome] })

      puts "      Outcome: #{scenario[:outcome]} (score: #{scenario[:score]})"
    end

    # Show adaptation results
    puts "\nğŸ§  Adaptation Results:"
    report = ai_manager.send(:get_performance_report)
    puts "   Decisions processed: #{report[:total_decisions]}"
    puts "   Success rate: #{(report[:success_rate] * 100).round(1)}%"
    puts "   Lessons learned: #{report[:recent_lessons].size}"

    # Test adaptation recommendation
    test_context = { oxygen_level: 18, debt_level: 15000 }
    adaptation = ai_manager.instance_variable_get(:@performance_tracker).get_adapted_decision_recommendation(test_context)

    if adaptation
      puts "\nğŸ¯ Adaptation Test:"
      puts "   Context: Critical oxygen (18%), High debt (15k GCC)"
      puts "   Recommended: #{adaptation[:recommended_action]}"
      puts "   Confidence: #{(adaptation[:confidence] * 100).round(1)}%"
      puts "   Based on: #{adaptation[:based_on_decisions]} similar decisions"
    end

    puts "\nâœ… Adaptation simulation complete!"
  end

  desc "Validate all patterns against game rules and physics"
  task validate_patterns: :environment do
    puts "\nğŸ” Validating All Mission Profile Patterns..."

    patterns_path = Rails.root.join('data', 'json-data', 'ai-manager', 'mission_profile_patterns.json')

    unless File.exist?(patterns_path)
      puts "   âŒ Pattern file not found: #{patterns_path}"
      puts "   Run 'rake ai_manager:extract_test_scenarios' first"
      next
    end

    patterns = JSON.parse(File.read(patterns_path))
    validator = AIManager::PatternValidator.new

    validation_results = {}
    summary = { total: patterns.count, validated: 0, experimental: 0, needs_review: 0, invalid: 0 }

    patterns.each do |pattern_id, pattern|
      puts "\n#{pattern_id}:"
      validation = validator.validate_pattern(pattern.symbolize_keys)

      puts "  Status: #{validation[:status].to_s.humanize}"
      puts "  Confidence: #{(validation[:confidence] * 100).round}%"

      if validation[:warnings].any?
        puts "  âš ï¸  Warnings:"
        validation[:warnings].each { |w| puts "    - #{w[:message]}" }
      end

      if validation[:errors].any?
        puts "  âŒ Errors:"
        validation[:errors].each { |e| puts "    - #{e[:message]}" }
      end

      # Update pattern with validation results
      pattern['status'] = validation[:status]
      pattern['confidence_score'] = validation[:confidence]
      pattern['validation_result'] = {
        valid: validation[:valid],
        warnings: validation[:warnings],
        errors: validation[:errors]
      }

      validation_results[pattern_id] = validation

      # Update summary
      case validation[:status]
      when :validated
        summary[:validated] += 1
      when :experimental
        summary[:experimental] += 1
      when :needs_review
        summary[:needs_review] += 1
      when :invalid
        summary[:invalid] += 1
      end
    end

    # Save updated patterns with validation results
    File.write(patterns_path, JSON.pretty_generate(patterns))

    puts "\nğŸ“Š Validation Summary:"
    puts "   Total patterns: #{summary[:total]}"
    puts "   âœ… Validated: #{summary[:validated]}"
    puts "   ğŸ§ª Experimental: #{summary[:experimental]}"
    puts "   âš ï¸  Needs review: #{summary[:needs_review]}"
    puts "   âŒ Invalid: #{summary[:invalid]}"

    puts "\nğŸ’¾ Updated patterns saved with validation status"
  end

  desc "Refine patterns based on performance data"
  task refine_patterns: :environment do
    puts "\nğŸ”§ Refining Patterns Based on Performance Data..."

    # This would be implemented when we have performance tracking
    puts "   Pattern refinement not yet implemented"
    puts "   This will be added when performance tracking is complete"
  end

  desc "Promote experimental patterns to validated status"
  task promote_patterns: :environment do
    puts "\nâ¬†ï¸  Promoting Successful Experimental Patterns..."

    patterns_path = Rails.root.join('data', 'json-data', 'ai-manager', 'mission_profile_patterns.json')

    unless File.exist?(patterns_path)
      puts "   âŒ Pattern file not found"
      next
    end

    patterns = JSON.parse(File.read(patterns_path))
    promoted_count = 0

    patterns.each do |pattern_id, pattern|
      if pattern['status'] == 'experimental' &&
         pattern['confidence_score']&.>=(0.8) &&
         pattern['uses']&.>=(10) &&
         pattern['success_rate']&.>=(0.75)

        puts "   Promoting #{pattern_id} to validated status"
        pattern['status'] = 'validated'
        pattern['promoted_at'] = Time.current.iso8601
        promoted_count += 1
      end
    end

    if promoted_count > 0
      File.write(patterns_path, JSON.pretty_generate(patterns))
      puts "\nâœ… Promoted #{promoted_count} patterns to validated status"
    else
      puts "   No patterns ready for promotion"
    end
  end

  desc "Comprehensive AI Luna base build test with detailed progress tracking"
  task :test_luna_base_build, [:iterations, :show_progress] => :environment do |t, args|
    iterations = (args[:iterations] || 1).to_i
    show_progress = args[:show_progress] == 'true'

    puts "\nğŸŒ™ === AI MANAGER LUNA BASE BUILD TEST ==="
    puts "Testing AI Manager's ability to construct Luna base using learned patterns"
    puts "Iterations: #{iterations}, Progress Display: #{show_progress ? 'Enabled' : 'Disabled'}"
    puts "=" * 80

    test_results = []
    start_time = Time.current

    iterations.times do |iteration|
      puts "\nğŸ”„ ITERATION #{iteration + 1}/#{iterations}"
      puts "-" * 50

      result = run_luna_base_build_test(show_progress)
      test_results << result

      # Show iteration summary
      puts "\nğŸ“Š ITERATION #{iteration + 1} SUMMARY:"
      puts "  Duration: #{result[:duration].round(2)}s"
      puts "  Success: #{result[:success] ? 'âœ…' : 'âŒ'}"
      puts "  Settlement Created: #{result[:settlement_created] ? 'âœ…' : 'âŒ'}"
      puts "  Final GCC Balance: #{result[:final_gcc_balance]}"
      puts "  Construction Jobs: #{result[:construction_jobs_completed]}"
      puts "  ISRU Efficiency: #{result[:isru_efficiency].round(3)}"
    end

    # Overall test summary
    total_duration = Time.current - start_time
    success_rate = (test_results.count { |r| r[:success] } / iterations.to_f * 100).round(1)

    puts "\nğŸ¯ === OVERALL TEST RESULTS ==="
    puts "=" * 80
    puts "Total Test Duration: #{total_duration.round(2)} seconds"
    puts "Success Rate: #{success_rate}% (#{test_results.count { |r| r[:success] }}/#{iterations})"
    puts "Average Build Time: #{(test_results.sum { |r| r[:duration] } / iterations).round(2)}s"
    puts "Average Final GCC: #{(test_results.sum { |r| r[:final_gcc_balance] } / iterations).round(0)}"

    # Performance analysis
    puts "\nğŸ“ˆ PERFORMANCE ANALYSIS:"
    successful_tests = test_results.select { |r| r[:success] }

    if successful_tests.any?
      avg_construction_jobs = (successful_tests.sum { |r| r[:construction_jobs_completed] } / successful_tests.size.to_f).round(1)
      avg_isru_efficiency = (successful_tests.sum { |r| r[:isru_efficiency] } / successful_tests.size.to_f).round(3)

      puts "  Average Construction Jobs: #{avg_construction_jobs}"
      puts "  Average ISRU Efficiency: #{avg_isru_efficiency}"
      puts "  Best Build Time: #{successful_tests.map { |r| r[:duration] }.min.round(2)}s"
      puts "  Worst Build Time: #{successful_tests.map { |r| r[:duration] }.max.round(2)}s"
    end

    # Recommendations
    puts "\nğŸ’¡ RECOMMENDATIONS:"
    if success_rate < 80
      puts "  âš ï¸  Low success rate - consider retraining AI with more lunar mission data"
      puts "  ğŸ“š Suggested: Add lunar_precursor mission patterns to training data"
    else
      puts "  âœ… High success rate - AI effectively learned lunar base construction"
    end

    if successful_tests.any? && avg_isru_efficiency < 0.7
      puts "  ğŸ”§ ISRU efficiency could be improved - review resource procurement patterns"
    end

    puts "\nğŸ”„ TO RETRAIN AI:"
    puts "  1. Update mission files in data/json-data/missions/"
    puts "  2. Run: rake ai_manager:extract_test_scenarios"
    puts "  3. Run: rake ai_manager:analyze_performance"
    puts "  4. Run: rake ai_manager:tune_ai_behavior"
    puts "  5. Re-test: rake ai_manager:test_luna_base_build"
  end

  # Helper method for comprehensive Luna base build testing
  def run_luna_base_build_test(show_progress)
    iteration_start = Time.current
    result = {
      success: false,
      settlement_created: false,
      duration: 0,
      final_gcc_balance: 0,
      construction_jobs_completed: 0,
      isru_efficiency: 0.0,
      phases_completed: [],
      procurement_summary: {},
      errors: []
    }

    begin
      # Phase 0: Setup and Analysis
      puts "\nğŸ“Š PHASE 0: SETUP & ANALYSIS" if show_progress
      puts "ğŸŒ™ Finding Luna in system data..." if show_progress

      luna = find_celestial_body_for_test('Luna')
      unless luna
        result[:errors] << "Luna not found in system data"
        return result
      end

      puts "âœ… Luna located: #{luna['name']} (#{luna['type']})" if show_progress

      # Create test settlement context
      puts "ğŸ—ï¸ Creating test settlement context..." if show_progress
      settlement = create_test_settlement_for_luna_test
      player = settlement.owner

      # Initialize tracking
      initial_balance = player.balance || 100000
      puts "ğŸ’° Initial GCC Balance: #{initial_balance.to_i}" if show_progress

      result[:initial_gcc_balance] = initial_balance

      # Phase 1: AI Analysis & Pattern Selection
      puts "\nğŸ¤– PHASE 1: AI ANALYSIS & PATTERN SELECTION" if show_progress

      analyzer = AISolSystemAnalyzer.new
      luna_analysis = analyzer.analyze_body(luna)

      puts "ğŸ“Š Luna Analysis Results:" if show_progress
      puts "  Terraformability: #{luna_analysis[:terraformability]}%" if show_progress
      puts "  Resources: #{luna_analysis[:resource_potential].join(', ')}" if show_progress
      puts "  Difficulty: #{luna_analysis[:development_difficulty]}" if show_progress
      puts "  Priority Score: #{luna_analysis[:priority_score]}" if show_progress

      # AI Pattern Selection
      selector = AIPatternSelector.new
      recommendations = selector.recommend_patterns(luna_analysis)
      selected_pattern = recommendations.first

      puts "ğŸ¯ AI Selected Pattern: #{selected_pattern[:pattern]}" if show_progress
      puts "  Score: #{selected_pattern[:score]}" if show_progress
      puts "  Reasons: #{selected_pattern[:reasons].join(', ')}" if show_progress

      result[:selected_pattern] = selected_pattern[:pattern]
      result[:pattern_score] = selected_pattern[:score]

      # Phase 2: Mission Execution with Progress Tracking
      puts "\nğŸš€ PHASE 2: MISSION EXECUTION" if show_progress

      mission_start = Time.current
      mission_result = execute_luna_mission_with_tracking(selected_pattern[:pattern], luna, settlement, show_progress)

      if mission_result[:success]
        result[:success] = true
        result[:settlement_created] = true
        result[:construction_jobs_completed] = mission_result[:jobs_completed] || 0
        result[:isru_efficiency] = mission_result[:isru_efficiency] || 0.0
        result[:phases_completed] = mission_result[:phases_completed] || []
        result[:procurement_summary] = mission_result[:procurement_summary] || {}

        puts "âœ… Mission execution successful!" if show_progress
        puts "  Construction Jobs: #{result[:construction_jobs_completed]}" if show_progress
        puts "  ISRU Efficiency: #{(result[:isru_efficiency] * 100).round(1)}%" if show_progress
      else
        result[:errors] << "Mission execution failed: #{mission_result[:error]}"
        puts "âŒ Mission execution failed: #{mission_result[:error]}" if show_progress
        return result
      end

      # Phase 3: Economic Analysis
      puts "\nğŸ’° PHASE 3: ECONOMIC ANALYSIS" if show_progress

      final_balance = player.reload.balance || 0
      gcc_spent = initial_balance - final_balance

      puts "ğŸ’° Final GCC Balance: #{final_balance.to_i}" if show_progress
      puts "ğŸ’¸ GCC Spent: #{gcc_spent.to_i}" if show_progress

      result[:final_gcc_balance] = final_balance
      result[:gcc_spent] = gcc_spent

      # Phase 4: Performance Metrics
      puts "\nğŸ“ˆ PHASE 4: PERFORMANCE METRICS" if show_progress

      mission_duration = Time.current - mission_start
      puts "â±ï¸ Mission Duration: #{mission_duration.round(2)} seconds" if show_progress

      # Compare to expected patterns
      comparison = compare_to_expected_patterns(selected_pattern[:pattern], mission_result)
      puts "ğŸ“Š Pattern Compliance: #{comparison[:compliance_score]}%" if show_progress

      if comparison[:issues].any?
        puts "âš ï¸ Issues Found:" if show_progress
        comparison[:issues].each { |issue| puts "  - #{issue}" } if show_progress
      end

      result[:pattern_compliance] = comparison[:compliance_score]
      result[:comparison_issues] = comparison[:issues]

    rescue => e
      result[:errors] << "Test execution error: #{e.message}"
      puts "âŒ Test failed with error: #{e.message}" if show_progress
    ensure
      result[:duration] = Time.current - iteration_start

      # Cleanup test data
      cleanup_test_settlement(settlement) if settlement
    end

    result
  end
    puts "\nğŸš€ Testing AI Manager with Generated Star System..."

    # Step 1: Generate a new star system
    puts "\nğŸŒŸ Generating new star system..."
    require Rails.root.join('app/services/star_sim/procedural_generator')

    generator = StarSim::ProceduralGenerator.new
    star_system = generator.generate_system_seed(num_stars: 1, num_planets: 8)

    # Save the generated system
    system_name = "test_system_#{Time.current.to_i}"
    system_path = GalaxyGame::Paths::STAR_SYSTEMS_PATH.join("#{system_name}.json")
    File.write(system_path, JSON.pretty_generate(star_system))

    puts "   âœ… Generated star system: #{system_name}"
    puts "   ğŸ“ Planets: #{star_system['celestial_bodies']&.count || star_system.dig('celestial_bodies', 'terrestrial_planets')&.count || 0}"
    puts "   ğŸ’¾ Saved to: #{system_path}"

    # Step 2: Create a mock settlement on the first habitable planet
    celestial_bodies_data = star_system["celestial_bodies"] || {}

    # Flatten all celestial bodies including nested moons
    all_celestial_bodies = []
    
    if celestial_bodies_data.is_a?(Array)
      # Array format
      celestial_bodies_data.each do |body|
        all_celestial_bodies << body
        # Add moons if they exist
        if body["moons"]
          body["moons"].each do |moon|
            moon["orbiting_body"] = body["name"]
            all_celestial_bodies << moon
          end
        end
      end
    else
      # Hash format
      celestial_bodies_data.each do |category, bodies|
        next unless bodies.is_a?(Array)
        
        bodies.each do |body|
          all_celestial_bodies << body
          
          # Add moons if they exist
          if body["moons"]
            body["moons"].each do |moon|
              moon["orbiting_body"] = body["name"]
              all_celestial_bodies << moon
            end
          end
        end
      end
    end

    habitable_planets = all_celestial_bodies.select do |body|
      (body['type'] == 'planet' || body['type'] == 'terrestrial' || body['type'] == 'terrestrial_planet') &&
      body['atmosphere'] &&
      (body['atmosphere']['oxygen']&.to_f || 0) > 0.1
    end

    if habitable_planets.empty?
      puts "   âš ï¸  No habitable planets found, creating settlement on first planet anyway"
      target_planet = all_celestial_bodies.find { |b| b['type'] == 'planet' || b['type'] == 'terrestrial' || b['type'] == 'terrestrial_planet' }
    else
      target_planet = habitable_planets.first
    end

    if target_planet.nil?
      puts "   âŒ No planets found in generated system"
      next
    end

    puts "\nğŸ›ï¸ Creating mock settlement on #{target_planet['name']}..."

    # Create mock settlement object
    mock_settlement = OpenStruct.new(
      id: "test_settlement_#{Time.current.to_i}",
      name: "AI Test Settlement",
      planet_name: target_planet['name'],
      star_system: system_name,
      settlement_state: {
        oxygen_level: target_planet.dig('atmosphere', 'oxygen')&.to_f || 0.0,
        water_level: target_planet.dig('resources', 'water')&.to_f || 0.0,
        food_level: 50.0, # Assume some baseline
        debt_level: 10000, # Start with some debt
        population: 100,
        infrastructure_level: 1
      }
      # celestial_body: target_planet  # Commented out to avoid .data method issue
    )

    puts "   âœ… Mock settlement created: #{mock_settlement.id}"
    puts "   ğŸ“Š Initial state:"
    puts "      Oxygen: #{mock_settlement.settlement_state[:oxygen_level]}%"
    puts "      Water: #{mock_settlement.settlement_state[:water_level]}%"
    puts "      Debt: #{mock_settlement.settlement_state[:debt_level]} GCC"
    puts "      Population: #{mock_settlement.settlement_state[:population]}"

    # Step 3: Initialize AI Manager and analyze settlement
    puts "\nğŸ§  Running AI settlement analysis..."

    require Rails.root.join('app/services/ai_manager/operational_manager')
    ai_manager = AIManager::OperationalManager.new(mock_settlement)

    # Get AI analysis by checking what decision it would make
    begin
      decision = ai_manager.make_decision

      puts "\nğŸ“‹ AI Settlement Analysis:"
      puts "   Current Decision: #{decision[:action]}"
      puts "   Reasoning: #{decision[:reason] || 'No specific reasoning provided'}"
    rescue => e
      puts "\nğŸ“‹ AI Settlement Analysis:"
      puts "   Note: Decision analysis encountered an issue: #{e.message}"
      puts "   This is expected for mock settlements without full world data"
    end

    # Show pattern matching results
    puts "\nğŸ¯ Pattern Matching Analysis:"
    begin
      pattern_matches = ai_manager.instance_variable_get(:@pattern_matcher)&.find_matching_patterns(mock_settlement.settlement_state) || []
      
      if pattern_matches.any?
        puts "   Top matching patterns:"
        pattern_matches.first(3).each do |match|
          puts "   â€¢ #{match[:pattern_id]} (#{match[:confidence]}% match)"
          puts "     Recommended: #{match[:recommended_decision]}"
        end
      else
        puts "   No strong pattern matches found"
      end
    rescue => e
      puts "   Pattern matching not available: #{e.message}"
    end

    # Step 5: Show performance tracking
    puts "\nğŸ“Š Performance Tracking:"
    begin
      report = ai_manager.get_performance_report
      puts "   Total decisions: #{report[:total_decisions]}"
      puts "   Success rate: #{(report[:success_rate] * 100).round(1)}%"
      puts "   Active patterns: #{report[:active_patterns]&.count || 0}"
    rescue => e
      puts "   Performance tracking not available: #{e.message}"
    end

    puts "\nâœ… AI Manager Test Complete!"
    puts "   Generated system: #{system_name}"
    puts "   Test settlement: #{mock_settlement.id}"
    puts "   AI analysis completed successfully"
  end

  desc "Test AI manager wormhole expansion using procedural generation"
  task :test_wormhole_expansion, [:system_name, :force_biosphere] => :environment do |t, args|
    system_name = args[:system_name] || 'procedural'
    force_biosphere = args[:force_biosphere] == 'true'
    puts "\nğŸŒ€ Testing AI Manager Wormhole Expansion..."

    if system_name == 'sol'
      # Load Sol system
      puts "\nğŸŒŒ Loading Sol System..."
      sol_system_path = GalaxyGame::Paths::STAR_SYSTEMS_PATH.join('sol-complete.json')
      unless File.exist?(sol_system_path)
        puts "   âŒ Sol system file not found: #{sol_system_path}"
        puts "   Run data generation first"
        next
      end
      system_seed = JSON.parse(File.read(sol_system_path))
      system_name = system_seed["name"]
      system_identifier = system_seed["identifier"]
      puts "   âœ… Loaded Sol system with #{system_seed['celestial_bodies']&.count || 0} celestial body categories"
    elsif system_name == 'earth_like'
      # Generate Earth-like system
      puts "\nğŸŒ Generating Earth-like System..."
      generator = StarSim::ProceduralGenerator.new
      system_seed = generator.generate_system_seed(num_stars: 1, num_planets: 4)
      
      # Modify one planet to be Earth-like
      if system_seed["celestial_bodies"]["terrestrial_planets"]
        earth_like_planet = system_seed["celestial_bodies"]["terrestrial_planets"].first
        if earth_like_planet
          earth_like_planet["name"] = "Gaia Prime"
          earth_like_planet["terraforming_difficulty"] = 1 # Very easy
          earth_like_planet["engineered_atmosphere"] = false
          earth_like_planet["atmosphere"] = {
            "N2" => {"percentage" => 78},
            "O2" => {"percentage" => 21},
            "Ar" => {"percentage" => 0.9},
            "CO2" => {"percentage" => 0.04},
            "breathable" => true
          }
          earth_like_planet["biosphere_attributes"] = {
            "biodiversity_index" => 0.9,
            "estimated_species_count" => 5000000
          }
          puts "   âœ… Created Earth-like planet: Gaia Prime"
        end
      end
      
      system_name = system_seed["solar_system"]["name"]
      system_identifier = system_seed["solar_system"]["identifier"]
    else
      # Step 1: Generate procedural star system
      puts "\nğŸŒŒ Generating Procedural Star System..."
      if force_biosphere
        puts "   ğŸ”¬ Forcing complex biosphere generation for testing..."
      end
      generator = StarSim::ProceduralGenerator.new(nil, nil, nil, nil, nil, force_biosphere)
      system_seed = generator.generate_system_seed(num_stars: 1, num_planets: 8)

      system_name = system_seed["solar_system"]["name"]
      system_identifier = system_seed["solar_system"]["identifier"]
    end

    puts "   System: #{system_name} (#{system_identifier})"
    puts "   Celestial bodies: #{system_seed["celestial_bodies"]&.count || 0}"

    # Save the generated system (only for procedural)
    if system_name != 'sol'
      system_path = GalaxyGame::Paths::GENERATED_STAR_SYSTEMS_PATH.join("#{system_identifier.downcase}.json")
      FileUtils.mkdir_p(GalaxyGame::Paths::GENERATED_STAR_SYSTEMS_PATH) unless File.directory?(GalaxyGame::Paths::GENERATED_STAR_SYSTEMS_PATH)
      File.write(system_path, JSON.pretty_generate(system_seed))
      puts "   System saved to: #{system_path}"
    end

    # Step 2: Create mock settlement for AI testing
    mock_settlement = OpenStruct.new(
      id: 'wormhole_test_settlement',
      location: system_identifier,
      system_data: system_seed
    )

    # Step 3: Initialize AI Manager
    puts "\nğŸ¤– Initializing AI Manager..."
    require Rails.root.join('app/services/ai_manager/operational_manager')
    ai_manager = AIManager::OperationalManager.new(mock_settlement)

    # Step 4: Analyze system characteristics
    puts "\nğŸ” Analyzing System Characteristics..."
    celestial_bodies_data = system_seed["celestial_bodies"] || {}

    # Flatten all celestial bodies including nested moons
    all_celestial_bodies = []
    
    if celestial_bodies_data.is_a?(Array)
      # Sol format: array of bodies
      celestial_bodies_data.each do |body|
        all_celestial_bodies << body
        # Add moons if they exist
        if body["moons"]
          body["moons"].each do |moon|
            moon["orbiting_body"] = body["name"] # Ensure orbiting_body is set
            all_celestial_bodies << moon
          end
        end
      end
    else
      # Procedural format: hash of categories
      celestial_bodies_data.each do |category, bodies|
        next unless bodies.is_a?(Array)
        
        bodies.each do |body|
          all_celestial_bodies << body
          
          # Add moons if they exist
          if body["moons"]
            body["moons"].each do |moon|
              moon["orbiting_body"] = body["name"] # Ensure orbiting_body is set
              all_celestial_bodies << moon
            end
          end
        end
      end
    end

    terraformable_bodies = all_celestial_bodies.select do |body|
      (body['type'] == 'planet' || body['type'] == 'terrestrial' || body['type'] == 'terrestrial_planet') && 
      (body['terraforming_difficulty'] || body['engineered_atmosphere'] || body['atmosphere']&.dig('breathable') || body['biosphere_attributes'])
    end

    resource_rich_bodies = all_celestial_bodies.select do |body|
      body['resources']&.any? || body['type'] == 'moon'
    end

    puts "   Terraformable bodies: #{terraformable_bodies.count}"
    puts "   Resource-rich bodies: #{resource_rich_bodies.count}"
    puts "   Total bodies: #{all_celestial_bodies.count}"

    # Step 5: AI Manager Decision Analysis
    puts "\nğŸ§  AI Manager Decision Analysis..."

    # Have AI analyze the system and make decisions
    analysis = ai_manager.analyze_system_for_expansion(system_seed, all_celestial_bodies)

    puts "   AI Analysis Results:"
    puts "      Recommended settlement target: #{analysis[:recommended_target] || 'None identified'}"
    puts "      Settlement strategy: #{analysis[:settlement_strategy] || 'Resource extraction'}"
    puts "      Priority resources: #{analysis[:priority_resources]&.join(', ') || 'None'}"
    puts "      Risk assessment: #{analysis[:risk_assessment] || 'Unknown'}"
    puts "      Estimated ROI timeline: #{analysis[:roi_timeline] || 'Unknown'}"

    # Generate settlement plan
    settlement_plan = ai_manager.generate_settlement_plan(system_seed, analysis)

    puts "\nğŸ“‹ AI-Generated Settlement Plan:"
    puts "   Mission Type: #{settlement_plan[:mission_type]}"
    puts "   Target Body: #{settlement_plan[:target_body]}"
    puts "   Infrastructure Requirements: #{settlement_plan[:infrastructure]&.join(', ') || 'None'}"
    puts "   Resource Procurement Strategy: #{settlement_plan[:procurement_strategy]}"
    puts "   Expected Challenges: #{settlement_plan[:challenges]&.join(', ') || 'None'}"
    puts "   Success Probability: #{(settlement_plan[:success_probability] * 100).round(1)}%"

    # Step 6: Record performance and show results
    puts "\nğŸ“Š Mission Performance Analysis..."

    # Record the AI's decision
    decision_record = {
      action: :wormhole_expansion_analysis,
      reasoning: "AI analysis of procedurally generated system #{system_name}: #{analysis[:recommended_target] ? "Settlement recommended on #{analysis[:recommended_target]}" : "No viable settlement target identified"}",
      expected_outcome: settlement_plan[:success_probability] > 0.7 ? :successful_colonization : :needs_further_assessment
    }

    # Record the decision
    puts "   Decision recorded: #{decision_record[:action]}"
    puts "   Reasoning: #{decision_record[:reasoning]}"

    # Step 7: Show final results
    puts "\nğŸ¯ Expansion Test Results:"
    puts "   âœ… System successfully analyzed: #{system_name}"
    puts "   âœ… AI settlement plan generated"
    puts "   âœ… Mission type: #{settlement_plan[:mission_type]}"
    puts "   ğŸ“ˆ Economic assessment: #{settlement_plan[:estimated_cost]} GCC investment"
    puts "   ğŸ”„ Resource potential: High (#{resource_rich_bodies.count} resource bodies identified)"

    # AI tuning insights
    puts "\nğŸ§  AI Tuning Insights:"
    puts "   â€¢ Procedural generator created viable expansion target"
    puts "   â€¢ AI recommended #{analysis[:settlement_strategy]} strategy"
    puts "   â€¢ Mission duration (#{settlement_plan[:estimated_duration_months]} months) estimated"
    puts "   â€¢ Consider 'super-mars' influence: boost terraformable chance for Mars-like planets"

    puts "\nâœ… Wormhole Expansion Test Complete!"
    puts "   Use this framework to tune procedural generation and AI decision-making"
    puts "   Run: rake ai_manager:test_wormhole_expansion[system_name,true]"
  end
end

namespace :exodus do
  desc "Stress test AI Manager's autonomous survey and settlement logic for wormhole discovery"
  task stress_test_wh_discovery: :environment do
    puts "\nğŸŒŒ Exodus: Wormhole Discovery Stress Test"
    puts "   Testing AI Manager autonomous survey and settlement logic"

    # Step 1: Initialize Sol system context
    puts "\nğŸ  Initializing Sol System Context..."
    sol_system_path = GalaxyGame::Paths::STAR_SYSTEMS_PATH.join('sol-complete.json')

    unless File.exist?(sol_system_path)
      puts "   âŒ Sol system data not found: #{sol_system_path}"
      puts "   Run procedural generation first"
      next
    end

    sol_data = JSON.parse(File.read(sol_system_path))
    puts "   âœ… Loaded Sol system with #{sol_data['celestial_bodies']&.count || 0} celestial bodies"

    # Step 2: Simulate natural wormhole detection
    puts "\nğŸŒ€ Simulating Natural Wormhole Detection..."
    puts "   Natural wormhole detected in Sol outer rim"
    puts "   Deploying stabilization satellites to secure both sides..."

    # Mock wormhole creation (simplified)
    mock_wormhole = OpenStruct.new(
      id: 'stress_test_wh_001',
      wormhole_type: 'natural',
      stability: 'unstable',
      solar_system_a: 'sol',
      solar_system_b: 'unknown'
    )

    # Step 3: Generate unknown procedural system
    puts "\nğŸŒŒ Generating Unknown Procedural System..."
    generator = StarSim::ProceduralGenerator.new
    unknown_system_seed = generator.generate_system_seed(num_stars: 1, num_planets: 6)

    unknown_system_name = unknown_system_seed["solar_system"]["name"]
    unknown_system_identifier = unknown_system_seed["solar_system"]["identifier"]

    puts "   Generated system: #{unknown_system_name} (#{unknown_system_identifier})"
    puts "   Celestial bodies: #{unknown_system_seed["celestial_bodies"]&.count || 0}"

    # Save the generated system
    unknown_system_path = GalaxyGame::Paths::GENERATED_STAR_SYSTEMS_PATH.join("#{unknown_system_identifier.downcase}.json")
    FileUtils.mkdir_p(GalaxyGame::Paths::GENERATED_STAR_SYSTEMS_PATH) unless File.directory?(GalaxyGame::Paths::GENERATED_STAR_SYSTEMS_PATH)
    File.write(unknown_system_path, JSON.pretty_generate(unknown_system_seed))
    puts "   System saved to: #{unknown_system_path}"

    # Step 4: Transit cycler and deploy scout probes
    puts "\nğŸš€ Executing Transit & Scouting Phase..."
    puts "   Cycler transiting through wormhole to #{unknown_system_name}"
    puts "   Deploying scout probes for comprehensive sensor sweep..."

    celestial_bodies = unknown_system_seed["celestial_bodies"] || {}

    # Flatten all celestial bodies including nested moons
    all_celestial_bodies = []
    
    # Add planets and their moons
    celestial_bodies.each do |category, bodies|
      next unless bodies.is_a?(Array)
      
      bodies.each do |body|
        all_celestial_bodies << body
        
        # Add moons if they exist
        if body["moons"]
          body["moons"].each do |moon|
            moon["orbiting_body"] = body["name"] # Ensure orbiting_body is set
            all_celestial_bodies << moon
          end
        end
      end
    end

    # Analyze system composition using flattened list
    large_moons = all_celestial_bodies.select do |body|
      body['type'] == 'moon' && body['diameter_km'].to_f > 1000
    end

    gas_giants = all_celestial_bodies.select do |body|
      body['type'] == 'gas_giant'
    end

    asteroids_small_moons = all_celestial_bodies.select do |body|
      ['asteroid', 'moon'].include?(body['type']) && body['diameter_km'].to_f < 1000
    end

    # Distinguish between free asteroids and planet-orbiting small moons
    free_asteroids = asteroids_small_moons.select do |body|
      body['type'] == 'asteroid' || body['orbiting_body'].nil?
    end

    orbiting_small_moons = asteroids_small_moons.select do |body|
      body['type'] == 'moon' && body['orbiting_body'].present?
    end

    terraformable_planets = all_celestial_bodies.select do |body|
      body['type'] == 'planet' && (body['terraforming']&.dig('terraformable') || body['atmosphere']&.dig('breathable'))
    end

    venus_like_planets = all_celestial_bodies.select do |body|
      body['type'] == 'planet' && body['atmosphere']&.dig('pressure').to_f > 10
    end

    puts "   ğŸ“Š System Analysis:"
    puts "      Large moons: #{large_moons.count}"
    puts "      Gas giants: #{gas_giants.count}"
    puts "      Asteroids/small moons: #{asteroids_small_moons.count}"
    puts "        - Free asteroids: #{free_asteroids.count}"
    puts "        - Orbiting small moons: #{orbiting_small_moons.count}"
    puts "      Terraformable planets: #{terraformable_planets.count}"
    puts "      Venus-like planets: #{venus_like_planets.count}"

    # Step 5: AI Analysis and Settlement Proposal
    puts "\nğŸ¤– AI Manager Analysis & Minimal Foothold Settlement Plan..."
    puts "   ğŸ“ˆ Prioritizing ROI and local resources for initial foothold establishment"

    # Load mission patterns for matching
    patterns_path = GalaxyGame::Paths::AI_MISSION_PATTERNS_PATH
    patterns = JSON.parse(File.read(patterns_path))

    settlement_recommendation = nil
    target_world = nil
    roi_timeline = nil
    foothold_strategy = nil

    # Apply prioritized rules for MINIMAL FOOTHOLD establishment
    if large_moons.any?
      # Rule A: Luna Priority - Leverage existing large moon infrastructure
      puts "   ğŸ¯ Rule A Applied: Large moon foothold - Maximum local resource leverage"
      target_world = large_moons.first['name']
      settlement_recommendation = 'Luna Pattern (Foothold)'
      roi_timeline = '6-9 months (local ISRU, minimal imports)'
      foothold_strategy = 'Immediate local resource exploitation - no imports needed'

      luna_pattern = patterns['lunar_pattern']
      if luna_pattern
        puts "   ğŸ“‹ Matched to existing pattern: #{luna_pattern['pattern_id']}"
        puts "   ğŸ“Š Pattern phases: #{luna_pattern['phase_structure']['total_phases']}"
      end

    elsif orbiting_small_moons.any?
      # Rule B: Mars/Super-Mars - Use existing orbital moons (no relocation)
      puts "   ğŸ¯ Rule B Applied: Orbital moon foothold - Zero relocation cost"
      target_world = orbiting_small_moons.first['name']
      settlement_recommendation = 'Mars Pattern (Foothold)'
      roi_timeline = '7-10 months (existing stable orbit, local resource focus)'
      foothold_strategy = 'Minimal orbital outpost using existing celestial mechanics'

      mars_pattern = patterns.find { |k,v| k.include?('mars') }&.last
      if mars_pattern
        puts "   ğŸ“‹ Matched to existing pattern: #{mars_pattern['pattern_id']}"
        puts "   ğŸ“Š Pattern phases: #{mars_pattern['phase_structure']['total_phases']}"
      end

    elsif free_asteroids.any?
      # Rule B: Mars/Super-Mars - Asteroid capture (higher cost but still foothold)
      puts "   ğŸ¯ Rule B Applied: Asteroid foothold - Controlled relocation investment"
      target_world = free_asteroids.first['name']
      settlement_recommendation = 'Mars Pattern (Foothold)'
      roi_timeline = '9-13 months (asteroid capture, orbital conversion)'
      foothold_strategy = 'Strategic asteroid utilization for expandable platform'

      mars_pattern = patterns.find { |k,v| k.include?('mars') }&.last
      if mars_pattern
        puts "   ğŸ“‹ Matched to existing pattern: #{mars_pattern['pattern_id']}"
        puts "   ğŸ“Š Pattern phases: #{mars_pattern['phase_structure']['total_phases']}"
      end

    elsif gas_giants.any?
      # Rule C: Hybrid Hub - Gas giant atmospheric harvesting
      puts "   ğŸ¯ Rule C Applied: Gas giant foothold - High-value resource access"
      target_world = gas_giants.first['name']
      settlement_recommendation = 'Hybrid Hub Pattern (Foothold)'
      roi_timeline = '10-15 months (atmospheric harvesting + moon logistics)'
      foothold_strategy = 'Gas giant resource exploitation with moon-based support'

      # Look for titan or gas giant patterns
      hybrid_pattern = patterns.find { |k,v| k.include?('titan') || k.include?('gas') }&.last
      if hybrid_pattern
        puts "   ğŸ“‹ Matched to existing pattern: #{hybrid_pattern['pattern_id']}"
        puts "   ğŸ“Š Pattern phases: #{hybrid_pattern['phase_structure']['total_phases']}"
      end

    elsif venus_like_planets.any?
      # Rule D: Venus Setup - Orbital harvesting (highest cost, last resort)
      puts "   ğŸ¯ Rule D Applied: Venus foothold - Extreme environment specialization"
      target_world = venus_like_planets.first['name']
      settlement_recommendation = 'Venus Pattern (Foothold)'
      roi_timeline = '12-18 months (orbital harvesting, environmental adaptation)'
      foothold_strategy = 'Specialized orbital operations for hostile environment'

      venus_pattern = patterns.find { |k,v| k.include?('venus') }&.last
      if venus_pattern
        puts "   ğŸ“‹ Matched to existing pattern: #{venus_pattern['pattern_id']}"
        puts "   ğŸ“Š Pattern phases: #{venus_pattern['phase_structure']['total_phases']}"
        puts "   ğŸ’° High cost due to extreme environmental conditions"
      end

    else
      puts "   âš ï¸  No suitable foothold targets found"
      puts "   ğŸ’¡ Recommendation: Extended survey or alternative system"
      settlement_recommendation = 'No viable foothold'
      roi_timeline = 'N/A'
      foothold_strategy = 'System unsuitable for initial colonization'
    end

    # Step 6: Calculate optimal wormhole placement
    puts "\nğŸ“ Calculating Optimal Wormhole Station Placement..."
    
    # Mock placement service for testing (TODO: Use real AIManager::WormholePlacementService when autoloading is fixed)
    mock_placement = OpenStruct.new(
      lagrange_point: 'L4',
      coordinates: [1.5e11, 0, 0],
      stability_assessment: 'Stable',
      stability_risk: 'Low'
    )

    if mock_placement
      puts "   âœ… Optimal L-point calculated"
      puts "   ğŸ“ Coordinates: (#{mock_placement.coordinates&.join(', ') || 'N/A'})"
      puts "   ğŸ›¡ï¸  Stability risk: #{mock_placement.stability_risk || 'N/A'}"
    else
      puts "   âš ï¸  Could not calculate optimal placement"
    end

    # Step 7: Generate Strategic Recommendation Report
    puts "\nğŸ“‹ STRATEGIC RECOMMENDATION REPORT"
    puts "=" * 50
    puts "System Discovered: #{unknown_system_name}"
    puts "Target World: #{target_world || 'None identified'}"
    puts "Settlement Pattern: #{settlement_recommendation}"
    puts "Projected ROI Timeline: #{roi_timeline}"
    puts "Foothold Strategy: #{foothold_strategy}"
    puts ""
    puts "System Composition:"
    puts "  â€¢ Celestial Bodies: #{all_celestial_bodies.count}"
    puts "  â€¢ Large Moons: #{large_moons.count}"
    puts "  â€¢ Gas Giants: #{gas_giants.count}"
    puts "  â€¢ Asteroids/Small Moons: #{asteroids_small_moons.count}"
    puts "    - Free asteroids: #{free_asteroids.count} (require relocation)"
    puts "    - Orbiting small moons: #{orbiting_small_moons.count} (no relocation needed)"
    puts "  â€¢ Terraformable Planets: #{terraformable_planets.count}"
    puts "  â€¢ Venus-like Planets: #{venus_like_planets.count}"
    puts ""
    puts "Wormhole Station Placement:"
    if mock_placement
      puts "  â€¢ L-point: #{mock_placement.lagrange_point || 'Calculated'}"
      puts "  â€¢ Stability Assessment: #{mock_placement.stability_assessment || 'Stable'}"
      puts "  â€¢ Construction Priority: High"
    else
      puts "  â€¢ Status: Calculation pending"
    end
    puts ""
    puts "Next Actions:"
    puts "  1. Deploy stabilization satellites"
    puts "  2. Launch cycler with settlement equipment"
    puts "  3. Establish initial foothold on #{target_world || 'target world'}"
    puts "  4. Begin resource extraction and infrastructure development"
    puts "=" * 50

    puts "\nâœ… Exodus Stress Test Complete!"
    puts "   AI Manager successfully analyzed new wormhole discovery"
    puts "   Settlement proposal generated based on system characteristics"
    puts "   Use results to tune AI decision logic and procedural generation"

    # Step 8: Generate AI Manager Plan Report File
    puts "\nğŸ“„ Generating AI Manager Settlement Plan Report..."

    report_path = Rails.root.join('ai_manager_settlement_plan.txt')
    report_content = []
    report_content << "AI MANAGER SETTLEMENT PLAN REPORT"
    report_content << "=" * 50
    report_content << "Generated: #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}"
    report_content << "Test Type: Exodus Wormhole Discovery Stress Test"
    report_content << ""
    report_content << "SYSTEM ANALYSIS"
    report_content << "-" * 20
    report_content << "System Discovered: #{unknown_system_name} (#{unknown_system_identifier})"
    report_content << "Celestial Bodies: #{all_celestial_bodies.count}"
    report_content << "  â€¢ Large Moons: #{large_moons.count}"
    report_content << "  â€¢ Gas Giants: #{gas_giants.count}"
    report_content << "  â€¢ Asteroids/Small Moons: #{asteroids_small_moons.count}"
    report_content << "    - Free asteroids: #{free_asteroids.count}"
    report_content << "    - Orbiting small moons: #{orbiting_small_moons.count}"
    report_content << "  â€¢ Terraformable Planets: #{terraformable_planets.count}"
    report_content << "  â€¢ Venus-like Planets: #{venus_like_planets.count}"
    report_content << ""
    report_content << "AI SETTLEMENT RECOMMENDATION"
    report_content << "-" * 30
    report_content << "Target World: #{target_world || 'None identified'}"
    report_content << "Settlement Pattern: #{settlement_recommendation}"
    report_content << "Projected ROI Timeline: #{roi_timeline}"
    report_content << "Foothold Strategy: #{foothold_strategy}"
    report_content << ""
    report_content << "WORMHOLE STATION PLACEMENT"
    report_content << "-" * 25
    if mock_placement
      report_content << "L-point: #{mock_placement.lagrange_point || 'Calculated'}"
      report_content << "Coordinates: #{mock_placement.coordinates&.join(', ') || 'N/A'}"
      report_content << "Stability Assessment: #{mock_placement.stability_assessment || 'Stable'}"
      report_content << "Stability Risk: #{mock_placement.stability_risk || 'N/A'}"
      report_content << "Construction Priority: High"
    else
      report_content << "Status: Calculation pending"
    end
    report_content << ""
    report_content << "NEXT ACTIONS"
    report_content << "-" * 12
    report_content << "1. Deploy stabilization satellites"
    report_content << "2. Launch cycler with settlement equipment"
    report_content << "3. Establish initial foothold on #{target_world || 'target world'}"
    report_content << "4. Begin resource extraction and infrastructure development"
    report_content << ""
    report_content << "AI DECISION LOGIC"
    report_content << "-" * 17
    if large_moons.any?
      report_content << "Applied Rule A: Large moon foothold priority"
      report_content << "Reasoning: Maximum local resource leverage, minimal import dependency"
    elsif orbiting_small_moons.any?
      report_content << "Applied Rule B: Orbital moon foothold priority"
      report_content << "Reasoning: Zero relocation cost, stable orbital mechanics"
    elsif free_asteroids.any?
      report_content << "Applied Rule B: Asteroid foothold with relocation"
      report_content << "Reasoning: Strategic asteroid utilization for expandable platform"
    elsif gas_giants.any?
      report_content << "Applied Rule C: Gas giant resource exploitation"
      report_content << "Reasoning: High-value atmospheric harvesting potential"
    elsif venus_like_planets.any?
      report_content << "Applied Rule D: Venus orbital operations"
      report_content << "Reasoning: Specialized operations for hostile environment"
    else
      report_content << "No viable foothold targets identified"
      report_content << "Recommendation: Extended survey or alternative system selection"
    end
    report_content << ""
    report_content << "=" * 50

    File.write(report_path, report_content.join("\n"))
    puts "   ğŸ“„ Report saved to: #{report_path}"
    puts "   ğŸ’¡ Use this report to analyze AI decision patterns and settlement logic"
  end
end

# Helper methods for Luna base build testing

def find_celestial_body_for_test(name)
  # Load Sol system data
  sol_path = Rails.root.join('data', 'json-data', 'star_systems', 'sol.json')
  return nil unless File.exist?(sol_path)

  sol_data = JSON.parse(File.read(sol_path))

  # Search through all celestial body collections
  collections = ['terrestrial_planets', 'gas_giants', 'dwarf_planets']
  collections.each do |collection|
    bodies = sol_data.dig('celestial_bodies', collection) || []
    body = bodies.find { |b| b['name'] == name }
    return body if body
  end

  nil
end

def create_test_settlement_for_luna_test
  # Create a test player
  player = Player.create!(
    name: "AI Luna Test Player #{Time.now.to_i}",
    active_location: "Luna Test Settlement"
  )

  # Find or create Luna
  luna = find_celestial_body_for_test('Luna')
  unless luna
    # Create mock Luna data
    luna = {
      'name' => 'Luna',
      'type' => 'moon',
      'mass' => 7.342e22,
      'radius' => 1.737e6,
      'surface_temperature' => 250,
      'known_pressure' => 0.0
    }
  end

  # Create location
  location = Location::CelestialLocation.create!(
    name: "Luna Test Location #{Time.now.to_i}",
    coordinates: "#{rand(0.00..90.00).round(2)}Â°N #{rand(0.00..180.00).round(2)}Â°E",
    celestial_body: CelestialBodies::Satellites::LargeMoon.find_or_create_by!(name: "Luna Test") do |moon|
      moon.identifier = "LUNA-TEST"
      moon.size = 0.273
      moon.gravity = 1.62
      moon.density = 3.344
      moon.mass = 7.342e22
      moon.radius = 1.737e6
      moon.orbital_period = 27.322
      moon.albedo = 0.12
      moon.insolation = 1361
      moon.surface_temperature = 250
      moon.known_pressure = 0.0
      moon.properties = {}
    end
  )

  # Create settlement
  settlement = Settlement::BaseSettlement.create!(
    name: "AI Luna Test Settlement #{Time.now.to_i}",
    settlement_type: "base",
    current_population: 0,
    operational_data: { test_settlement: true },
    owner: player,
    location: location
  )

  # Add initial resources
  settlement.inventory.add_item("regolith", 1000)
  settlement.inventory.add_item("oxygen", 100)
  settlement.inventory.add_item("water", 50)
  settlement.save!

  settlement
end

def execute_luna_mission_with_tracking(mission_pattern, luna, settlement, show_progress)
  result = {
    success: false,
    jobs_completed: 0,
    isru_efficiency: 0.0,
    phases_completed: [],
    procurement_summary: {},
    error: nil
  }

  begin
    # Initialize tracking
    initial_inventory = ResourceTrackingService.track_inventory_snapshot(settlement)
    initial_balance = settlement.owner.balance || 0

    puts "ğŸ“¦ Initial Inventory: #{initial_inventory['total_items']} items" if show_progress
    puts "ğŸ’° Initial GCC: #{initial_balance.to_i}" if show_progress

    # Execute mission based on pattern
    case mission_pattern
    when /lunar_precursor/
      result = execute_lunar_precursor_mission(settlement, show_progress)
    when /isru_focused/
      result = execute_isru_focused_mission(settlement, show_progress)
    else
      # Fallback to basic lunar mission
      result = execute_basic_lunar_mission(settlement, show_progress)
    end

    # Track final state
    if result[:success]
      final_inventory = ResourceTrackingService.track_inventory_snapshot(settlement)
      final_balance = settlement.owner.reload.balance || 0

      gcc_spent = initial_balance - final_balance
      inventory_change = final_inventory['total_items'] - initial_inventory['total_items']

      puts "ğŸ“¦ Final Inventory: #{final_inventory['total_items']} items (#{inventory_change > 0 ? '+' : ''}#{inventory_change})" if show_progress
      puts "ğŸ’° Final GCC: #{final_balance.to_i} (spent: #{gcc_spent.to_i})" if show_progress

      # Calculate ISRU efficiency (local production vs imports)
      result[:procurement_summary] = calculate_procurement_summary(settlement)
      result[:isru_efficiency] = calculate_isru_efficiency(result[:procurement_summary])
    end

  rescue => e
    result[:error] = e.message
    puts "âŒ Mission execution error: #{e.message}" if show_progress
  end

  result
end

def execute_lunar_precursor_mission(settlement, show_progress)
  phases = [
    { name: "Landing & Setup", duration: 30, tasks: ["deploy_initial_equipment", "establish_comms"] },
    { name: "Power & Infrastructure", duration: 45, tasks: ["deploy_power_system", "setup_basic_habitat"] },
    { name: "ISRU Setup", duration: 60, tasks: ["deploy_harvesters", "setup_oxygen_generation"] },
    { name: "Expansion", duration: 90, tasks: ["expand_habitat", "optimize_operations"] }
  ]

  result = { success: true, jobs_completed: 0, phases_completed: [] }

  phases.each_with_index do |phase, index|
    puts "ğŸ—ï¸ Phase #{index + 1}: #{phase[:name]}" if show_progress

    # Simulate phase execution
    phase_success = simulate_mission_phase(phase, settlement)

    if phase_success
      result[:phases_completed] << phase[:name]
      result[:jobs_completed] += phase[:tasks].size
      puts "âœ… Phase completed successfully" if show_progress
    else
      result[:success] = false
      result[:error] = "Phase #{phase[:name]} failed"
      break
    end

    sleep(0.1) # Small delay for realism
  end

  result
end

def execute_isru_focused_mission(settlement, show_progress)
  # Similar to lunar precursor but with more emphasis on ISRU
  result = execute_lunar_precursor_mission(settlement, show_progress)
  result[:isru_focused] = true
  result
end

def execute_basic_lunar_mission(settlement, show_progress)
  # Basic mission for fallback
  puts "ğŸ”§ Executing basic lunar mission..." if show_progress

  # Simulate basic construction
  settlement.inventory.add_item("oxygen", 500)
  settlement.inventory.add_item("water", 200)

  { success: true, jobs_completed: 3, phases_completed: ["Basic Setup", "Resource Generation"] }
end

def simulate_mission_phase(phase, settlement)
  # Simulate phase execution with some randomness for realism
  success_probability = 0.85 # 85% success rate

  # Add resources based on phase
  case phase[:name]
  when /Landing/
    settlement.inventory.add_item("comms_equipment", 1)
  when /Power/
    settlement.inventory.add_item("nuclear_reactor", 1)
    settlement.inventory.add_item("solar_panels", 2)
  when /ISRU/
    settlement.inventory.add_item("oxygen", 300)
    settlement.inventory.add_item("water", 150)
  when /Expansion/
    settlement.inventory.add_item("habitation_module", 2)
  end

  rand < success_probability
end

def calculate_procurement_summary(settlement)
  # Mock procurement summary - in real implementation would query actual procurement records
  {
    total_procured: 1500,
    by_method: { isru: 1200, market: 200, imports: 100 },
    by_material: { oxygen: 500, water: 300, regolith: 700 }
  }
end

def calculate_isru_efficiency(procurement_summary)
  return 0.0 unless procurement_summary[:total_procured] && procurement_summary[:total_procured] > 0

  isru_amount = procurement_summary[:by_method][:isru] || 0
  isru_amount.to_f / procurement_summary[:total_procured]
end

def compare_to_expected_patterns(pattern_used, mission_result)
  # Compare actual results to expected patterns
  expected_patterns = {
    'lunar_precursor' => {
      expected_phases: 4,
      expected_jobs: 12,
      expected_isru_efficiency: 0.8
    },
    'isru_focused_base' => {
      expected_phases: 4,
      expected_jobs: 15,
      expected_isru_efficiency: 0.9
    }
  }

  expected = expected_patterns[pattern_used] || expected_patterns['lunar_precursor']

  compliance_score = 100
  issues = []

  # Check phase completion
  phase_compliance = (mission_result[:phases_completed].size.to_f / expected[:expected_phases]) * 100
  if phase_compliance < 80
    compliance_score -= 20
    issues << "Incomplete phase execution (#{mission_result[:phases_completed].size}/#{expected[:expected_phases]})"
  end

  # Check job completion
  job_compliance = (mission_result[:jobs_completed].to_f / expected[:expected_jobs]) * 100
  if job_compliance < 70
    compliance_score -= 15
    issues << "Low job completion rate (#{mission_result[:jobs_completed]}/#{expected[:expected_jobs]})"
  end

  # Check ISRU efficiency
  if mission_result[:isru_efficiency] < expected[:expected_isru_efficiency] * 0.8
    compliance_score -= 10
    issues << "ISRU efficiency below expected (#{mission_result[:isru_efficiency].round(3)} < #{expected[:expected_isru_efficiency]})"
  end

  { compliance_score: [compliance_score, 0].max, issues: issues }
end

def cleanup_test_settlement(settlement)
  # Clean up test data
  if settlement && settlement.persisted?
    settlement.owner&.destroy
    settlement.location&.destroy
    settlement.destroy
  end
end