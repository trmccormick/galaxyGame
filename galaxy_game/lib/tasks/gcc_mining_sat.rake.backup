# lib/tasks/gcc_mining_sat.rake
# docker compose exec web bundle exec rake orbital_mining:gcc_sat
require 'json'
require 'securerandom'

namespace :orbital_mining do
  desc "Simulate GCC Mining Satellite Deployment and Operation"
  task gcc_sat: :environment do
    puts "\nüöÄ Starting GCC Mining Satellite Integration Test..."

    # === Bond maturity period (days) ===
    bond_maturity_days = 180
    game_days = (ENV['GAME_DAYS']&.to_i || bond_maturity_days + 1)
    puts "\nSimulating #{game_days} game days..."

    game = Game.new
    game_state = game.game_state

    # === 1. Load Manifest ===
    puts "\n1. Loading mission manifest..."
    manifest_path = GalaxyGame::Paths::JSON_DATA.join('missions', 'gcc_sat_mining_deployment', 'crypto_mining_satellite_01_manifest_v2.json')
    manifest = JSON.parse(File.read(manifest_path))
    puts "‚úî Manifest loaded: #{manifest['manifest_id'] || 'Unnamed Phase'}"

    craft_lookup_service = Lookup::CraftLookupService.new
    unit_lookup_service = Lookup::UnitLookupService.new
    module_lookup_service = Lookup::ModuleLookupService.new
    rig_lookup_service = Lookup::RigLookupService.new
    blueprint_service = Lookup::BlueprintLookupService.new

    # === 2. Load mission profile and extract location ===
    puts "\n2. Loading mission profile..."
    profile_path = GalaxyGame::Paths::JSON_DATA.join('missions', 'gcc_sat_mining_deployment', 'gcc_mining_satellite_01_profile_v1.json')
    profile = JSON.parse(File.read(profile_path))
    start_location_type = profile.dig('start_conditions', 'location') || 'planetary_orbit'
    puts "‚úî Profile loaded: Start location type: #{start_location_type}"

    # === 3. Load Phases ===
    puts "\n3. Loading mission phases..."
    phases_path = GalaxyGame::Paths::JSON_DATA.join('missions', 'gcc_sat_mining_deployment', 'gcc_mining_satellite_01_phases_v1.json')
    phases = JSON.parse(File.read(phases_path))
    puts "‚úî Phases loaded: #{phases['phase_description']}"

    # === 4. Load Continuous Tasks ===
    puts "\n4. Loading continuous mining tasks..."
    task_list_file = profile.dig('phases', 0, 'task_list_file') || 'gcc_satellite_mining_tasks_v1.json'
    task_path = GalaxyGame::Paths::JSON_DATA.join('missions', 'gcc_sat_mining_deployment', task_list_file)
    task_list = File.exist?(task_path) ? JSON.parse(File.read(task_path)) : []
    puts "‚úî Loaded #{task_list.length} mining tasks"

    # === 5. Setup celestial context and owning organization ===
    puts "\n4. Setting up orbiting context and LDC..."
    earth = CelestialBodies::Planets::Rocky::TerrestrialPlanet.where(name: "Earth").first ||
            CelestialBodies::CelestialBody.where(name: "Earth").first
    if earth.nil?
      puts "  Creating Earth..."
      earth = CelestialBodies::Planets::Rocky::TerrestrialPlanet.create!(
        name: "Earth",
        identifier: 'EARTH-01',
        mass: 5.972e24,
        size: 6371.0,
        gravity: 9.807
      )
    end
    puts "‚úÖ Found Earth (ID: #{earth.id}, Identifier: #{earth.identifier})"

    orbit_location = Location::CelestialLocation.find_or_create_by(coordinates: "0.00¬∞N 0.00¬∞E", celestial_body: earth) do |loc|
      loc.name = "Planetary Orbit"
    end
    puts "‚úÖ Using location: #{orbit_location.name} (ID: #{orbit_location.id})"

    # LDC: The Issuer of the Bond and Owner of the Satellite project
    ldc = Organizations::BaseOrganization.find_or_create_by!(identifier: 'LDC') do |org|
      org.name = 'Lunar Development Corporation'
      org.organization_type = :development_corporation
    end
    ldc.update!(operational_data: { 'is_npc' => true })
    puts "‚úÖ Using organization: #{ldc.name} (ID: #{ldc.id})"

    # === 6. Setup Currencies and Accounts ===
    puts "\n6. Setting up Currencies and LDC Accounts..."
    gcc_currency = Financial::Currency.find_by(symbol: 'GCC')
    usd_currency = Financial::Currency.find_by(symbol: 'USD')
    raise "‚ùå GCC or USD Currency not found. Please run `rails db:seed`." unless gcc_currency && usd_currency
    puts "‚úÖ Found GCC Currency (ID: #{gcc_currency.id}, Symbol: #{gcc_currency.symbol})"
    puts "‚úÖ Found USD Currency (ID: #{usd_currency.id}, Symbol: #{usd_currency.symbol})"

    ldc_gcc_account = Financial::Account.find_or_create_for_entity_and_currency(accountable_entity: ldc, currency: gcc_currency)
    ldc_usd_account = Financial::Account.find_or_create_for_entity_and_currency(accountable_entity: ldc, currency: usd_currency)
    puts "‚úÖ LDC's GCC Account: ID #{ldc_gcc_account.id}, Initial Balance: #{ldc_gcc_account.balance.to_f} GCC"
    puts "‚úÖ LDC's USD Account: ID #{ldc_usd_account.id}, Initial Balance: #{ldc_usd_account.balance.to_f} USD"

    # === 6. Setup AstroLift and their accounts ===
    puts "\n6. Setting up AstroLift and their accounts..."
    # AstroLift: The Logistics/Operator launching the satellite
    astrolift = Organizations::BaseOrganization.find_or_create_by!(identifier: 'ASTROLIFT') do |org|
      org.name = 'AstroLift'
      org.organization_type = :corporation
    end
    astrolift.update!(operational_data: { 'is_npc' => true })
    puts "‚úÖ Using organization: #{astrolift.name} (ID: #{astrolift.id})"
    astrolift_gcc_account = Financial::Account.find_or_create_for_entity_and_currency(accountable_entity: astrolift, currency: gcc_currency)
    astrolift_gcc_account.update(balance: 0.0)
    astrolift_usd_account = Financial::Account.find_or_create_for_entity_and_currency(accountable_entity: astrolift, currency: usd_currency)
    puts "‚úÖ AstroLift's GCC Account: ID #{astrolift_gcc_account.id}, Balance: #{astrolift_gcc_account.balance.to_f} GCC"
    puts "‚úÖ AstroLift's USD Account: ID #{astrolift_usd_account.id}, Balance: #{astrolift_usd_account.balance.to_f} USD"

    # === 7. Build and deploy satellite ===
    blueprint_id = manifest.dig("craft", "blueprint_id") || "generic_satellite"
    satellite = Manufacturing::CraftFactory.build_from_blueprint(
      blueprint_id: blueprint_id,
      variant_data: manifest["variant_data"],
      owner: ldc,
      location: orbit_location
    )
    raise "Satellite build failed" unless satellite&.persisted?

    if manifest["operational_data"]
      satellite.update!(operational_data: manifest["operational_data"])
    end

    orbit_location.update(locationable: satellite)
    satellite.reload

    valid_locations = satellite.operational_data.dig('deployment', 'deployment_locations') || []
    start_location_type = profile.dig('start_conditions', 'location') || 'planetary_orbit'
    if valid_locations.include?(start_location_type)
      satellite.deploy(start_location_type, celestial_body: earth)
    else
      puts "‚ö†Ô∏è Profile location type '#{start_location_type}' not supported by satellite."
      puts "‚úÖ Using 'orbital' instead."
      satellite.deploy('orbital', celestial_body: earth)
    end
    satellite.reload
    puts "‚úî Satellite deployed: #{satellite.name} in orbit around #{earth.name}"

    # === 8. Fit components automatically ===
    puts "\n8. Fitting components automatically..."
    fit_data = (manifest["operational_data"] && manifest["operational_data"]['recommended_fit']) ||
               manifest.dig("variant_data", "recommended_fit") ||
               satellite.operational_data['recommended_fit']

    if fit_data
      fit_result = FittingService.fit!(
        target: satellite,
        fit_data: fit_data
      )
      if fit_result.success?
        puts "  ‚úÖ Successfully fitted craft with recommended components"
      else
        puts "  ‚ùå Failed to fit craft: #{fit_result.errors.join(', ')}"
      end
    else
      puts "  ‚ö†Ô∏è No fit data found, skipping automatic fitting"
    end

    # Initialize battery charge
    battery_unit = satellite.base_units.find { |unit| unit.unit_type == 'satellite_battery' }
    if battery_unit
      capacity = battery_unit.operational_data.dig('battery', 'capacity') || 1000.0
      battery_unit.operational_data['battery'] ||= {}
      battery_unit.operational_data['battery']['current_charge'] = capacity
      battery_unit.save!
      puts "  ‚úÖ Battery charged to #{capacity} kWh"
    end
    satellite.reload

    # === 9. Calculate Satellite Mass and Pay Launch Costs ===
    puts "\n9. Calculating satellite mass and paying AstroLift for launch costs..."

    bp_id = manifest.dig("craft", "blueprint_id") || "generic_satellite"
    sat_bp = blueprint_service.find_blueprint(bp_id, "satellite") ||
             blueprint_service.find_blueprint("Generic Satellite", "satellite")
    base_mass_kg = sat_bp&.dig("physical_properties", "empty_mass_kg").to_f rescue 0.0

    puts "    Satellite base mass: #{base_mass_kg > 0 ? base_mass_kg : 'N/A'} kg"

    def find_unit_blueprint(blueprint_service, unit_type)
      %w[unit computers energy propulsion storage].each do |cat|
        bp = blueprint_service.find_blueprint(unit_type, cat)
        return bp if bp
      end
      nil
    end

    def extract_unit_mass(unit_bp)
      mass = unit_bp.dig("physical_properties", "empty_mass_kg") ||
             unit_bp.dig("physical_properties", "mass_kg")
      return mass.to_f if mass
      mass = unit_bp.dig("operational_data_reference", "physical_properties", "mass_kg")
      return mass.to_f if mass
      if unit_bp["required_materials"]
        estimated_mass = unit_bp["required_materials"].values.select { |mat| mat["unit"] == "kilogram" }.sum { |mat| mat["amount"].to_f }
        return estimated_mass if estimated_mass > 0
      end
      0.0
    end

    units_mass_kg = satellite.base_units.sum do |unit|
      unit_bp = find_unit_blueprint(blueprint_service, unit.unit_type)
      if unit_bp
        unit_mass = extract_unit_mass(unit_bp)
        puts "    Unit #{unit.name} mass: #{unit_mass > 0 ? unit_mass : 'N/A'} kg"
        unit_mass
      else
        puts "    ‚ö†Ô∏è No blueprint found for unit_type: #{unit.unit_type}"
        0.0
      end
    end

    total_mass_kg = base_mass_kg + units_mass_kg
    total_mass_lbs = total_mass_kg * 2.20462

    if total_mass_lbs <= 0
      puts "  ‚ö†Ô∏è WARNING: Satellite mass could not be determined. Using default mass of 2000 lbs."
      total_mass_lbs = 2000.0
    end
    puts "  - Calculated satellite mass: #{total_mass_kg.round(2)} kg (#{total_mass_lbs.round(2)} lbs)"

    launch_cost_usd = (total_mass_lbs * 1200).round(2)

    max_gcc_portion = (launch_cost_usd * 0.5).round(2)
    available_gcc = ldc_gcc_account.balance.to_f
    gcc_paid = [max_gcc_portion, available_gcc].min.round(2)
    usd_paid = (launch_cost_usd - gcc_paid).round(2)

    puts "LDC USD Balance before launch payment: #{ldc_usd_account.balance.to_f} USD"
    puts "LDC GCC Balance before launch payment: #{ldc_gcc_account.balance.to_f} GCC"

    if gcc_paid > 0
      ldc_gcc_account.transfer_funds(gcc_paid, astrolift_gcc_account, "Satellite launch service fee (GCC portion)")
    end

    usd_available = ldc_usd_account.balance.to_f
    usd_cash_paid = [usd_paid, usd_available].min.round(2)
    usd_bond_amount = (usd_paid - usd_cash_paid).round(2)

    if usd_paid > 0
      ldc_usd_account.transfer_funds(usd_paid, astrolift_usd_account, "Satellite launch service fee (USD portion)")
      usd_bond_amount = 0
    end

    bond = nil
    if usd_bond_amount > 0
      issued_at = Date.new(game_state.year, 1, 1) + (game_state.day - 1)
      due_at = issued_at + bond_maturity_days
      bond = Financial::Bond.create!(
        issuer: ldc,
        holder: astrolift,
        currency: usd_currency,
        amount: usd_bond_amount,
        issued_at: issued_at,
        due_at: due_at,
        status: :issued,
        description: "Bond issued for unpaid launch cost (USD portion)"
      )
      puts "ü™ô LDC issued a bond to AstroLift for #{usd_bond_amount} USD (unpaid portion of launch cost). Bond ID: #{bond.id}"
    end

    puts "‚úÖ LDC paid #{usd_paid} USD and #{gcc_paid} GCC to AstroLift for launch."
    puts "   LDC USD Balance: #{ldc_usd_account.reload.balance.to_f} USD"
    puts "   LDC GCC Balance: #{ldc_gcc_account.reload.balance.to_f} GCC"
    puts "   AstroLift USD Balance: #{astrolift_usd_account.reload.balance.to_f} USD"
    puts "   AstroLift GCC Balance: #{astrolift_gcc_account.reload.balance.to_f} GCC"

    # === 10. Verifying power systems ===
    puts "\n10. Verifying power systems..."
    power_gen = satellite.power_generation
    power_use = satellite.power_usage
    power_balance = power_gen - power_use
    puts "  - Power Generation: #{power_gen.round(2)} kW"
    puts "  - Power Usage: #{power_use.round(2)} kW"
    puts "  - Power Balance: #{power_balance.round(2)} kW"
    battery_unit = satellite.base_units.find { |unit| unit.unit_type == 'satellite_battery' }
    if battery_unit
      battery_capacity = battery_unit.operational_data.dig('battery', 'capacity') || 0
      battery_charge = battery_unit.operational_data.dig('battery', 'current_charge') || 0
      puts "  - Battery Unit: #{battery_unit.name}"
      puts "  - Battery Capacity: #{battery_capacity.round(2)} kWh"
      puts "  - Current Charge: #{battery_charge.round(2)} kWh (#{(battery_charge / battery_capacity * 100).round(1)}%)"
      if power_balance < 0
        puts "  ‚ö†Ô∏è WARNING: Power deficit detected. Mining will rely on batteries."
        hours_remaining = battery_charge / power_use.abs
        puts "  - Estimated battery duration: #{hours_remaining.round(1)} hours"
      else
        puts "  ‚úÖ Power systems nominal. Generating surplus of #{power_balance.round(2)} kW"
      end
    else
      puts "  ‚ö†Ô∏è WARNING: No battery units installed. Mining will halt during eclipses."
    end

    # === 11. Initial Mining Test ===
    puts "\n11. Performing first mining cycle..."
    initial_gcc_amount = satellite.mine_gcc
    if initial_gcc_amount.positive?
      ldc_gcc_account.deposit(initial_gcc_amount, "Initial GCC mining from #{satellite.name}")
      puts "‚úî Initial GCC mined: #{initial_gcc_amount}. Deposited to LDC Account. New Balance: #{ldc_gcc_account.balance.to_f} GCC"
    else
      puts "‚ùå No GCC mined in first cycle"
    end

    # === 12. Simulate Game Days Mining ===
    puts "\n12. Simulating mining over game days using Game loop..."
    game_days.times do |day|
      game.advance_by_days(1, update_planets: false)
      game_state.reload
      current_date = Date.new(game_state.year, 1, 1) + (game_state.day - 1)

      mined_gcc = satellite.mine_gcc
      if mined_gcc.positive?
        ldc_gcc_account.deposit(mined_gcc, "Daily GCC mining from #{satellite.name}")
        puts "  - Mined GCC: #{mined_gcc}"
      end

      puts "\nüìÖ Game Day #{day + 1} (Simulated Date: #{current_date.strftime('%Y-%m-%d')})..."
      puts "  - LDC GCC Balance: #{ldc_gcc_account.reload.balance.to_f} GCC"
      battery_unit = satellite.base_units.find { |unit| unit.unit_type == 'satellite_battery' }
      if battery_unit
        charge = battery_unit.operational_data.dig('battery', 'current_charge') || 0
        capacity = battery_unit.operational_data.dig('battery', 'capacity') || 0
        puts "  - Battery Level: #{charge.round(2)}/#{capacity} kWh (#{(charge/capacity*100).round(1)}%)"
      end
      sleep(0.2)
    end

    # === 13. Bond Maturity and Repayment ===
    puts "\n13. Bond Maturity and Repayment..."
    exchange_service = ExchangeRateService.new({ ["USD", "GCC"] => 1.0 }) # Set your rate here

    bonds = Financial::Bond.where(issuer: ldc, holder: astrolift, status: :issued)
    bonds.each do |bond|
      current_date = Date.new(game_state.year, 1, 1) + (game_state.day - 1)
      if current_date >= bond.due_at
        gcc_amount = exchange_service.convert(bond.amount, "USD", "GCC").round(2)
        available_gcc = ldc_gcc_account.balance.to_f

        if available_gcc >= gcc_amount
          ldc_gcc_account.transfer_funds(gcc_amount, astrolift_gcc_account, "Bond repayment in GCC for Bond ##{bond.id}")
          bond.update!(status: :paid)
          puts "üí∏ Bond ##{bond.id} repaid: #{gcc_amount} GCC transferred to AstroLift."
        else
          puts "‚ö†Ô∏è Not enough GCC to repay Bond ##{bond.id}. Outstanding: #{gcc_amount} GCC, Available: #{available_gcc} GCC"
        end
      else
        puts "‚è≥ Bond ##{bond.id} not yet matured. Due: #{bond.due_at.strftime('%Y-%m-%d')}"
      end
    end

    # === 14. Final Verification ===
    puts "\n‚úÖ Final Satellite Status:"
    puts "  - Satellite: #{satellite.name}"
    puts "  - Owner: #{satellite.owner.name}"
    puts "  - Online: #{satellite.deployed? ? 'Yes' : 'No'}"
    puts "  - Units: #{satellite.base_units.count}"

    ldc_gcc_account.reload
    ldc_usd_account.reload
    puts "  - LDC GCC Account Balance: #{ldc_gcc_account.balance.to_f} GCC"
    puts "  - LDC USD Account Balance: #{ldc_usd_account.balance.to_f} USD"

    astrolift_gcc_account.reload
    astrolift_usd_account.reload
    puts "  - AstroLift GCC Account Balance: #{astrolift_gcc_account.balance.to_f} GCC"
    puts "  - AstroLift USD Account Balance: #{astrolift_usd_account.balance.to_f} USD"

    puts "\nüìú Outstanding Bonds:"
    outstanding_bonds = Financial::Bond.where(issuer: ldc, holder: astrolift, status: :issued)
    if outstanding_bonds.any?
      outstanding_bonds.each do |bond|
        puts "  - Bond ID: #{bond.id}, Amount: #{bond.amount} #{bond.currency.symbol}, Issued: #{bond.issued_at.strftime('%Y-%m-%d')}, Due: #{bond.due_at&.strftime('%Y-%m-%d')}, Status: #{bond.status}"
      end
    else
      puts "  - None"
    end

    begin
      if MiningLog.table_exists?
        mining_logs = MiningLog.where(owner: satellite)
        puts "  - Mining Logs: #{mining_logs.count}"
      else
        puts "  ‚ö†Ô∏è MiningLog table not found. Did you run `rails db:migrate` after creating the migration?"
      end
    rescue ActiveRecord::ActiveRecordError => e
      puts "  ‚ùå Error accessing MiningLogs: #{e.message}. Ensure database is set up correctly."
    end

    battery_unit = satellite.base_units.find { |unit| unit.unit_type == 'satellite_battery' }
    if battery_unit
      capacity = battery_unit.operational_data.dig('battery', 'capacity') || 0
      charge = battery_unit.operational_data.dig('battery', 'current_charge') || 0
      puts "  - Battery Level: #{charge.round(2)}/#{capacity} kWh (#{(charge/capacity*100).round(1)}%)"
    else
      puts "  - No battery unit installed."
    end

    puts "\nüèÅ GCC Mining Satellite Integration Test Complete!"
  end
end